[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Home",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nSensitivity, Specificity, ROC Curve and AUC\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNaive Bayes Model\n\n\n\n\n\n\nML\n\n\nClassification\n\n\n\nA self use function for Naive Bayes classifier\n\n\n\n\n\nOct 14, 2024\n\n\nCreo Hsia\n\n\n\n\n\n\n\n\n\n\n\n\nRcpp Study Record\n\n\n\n\n\nRecord my study in Rcpp\n\n\n\n\n\nOct 10, 2024\n\n\nCreo Hsia\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome~~",
    "section": "",
    "text": "Hi! You can call me Creo. I am a graduate student specializing in statistics, working under the supervision of Yaowu Liu.\nThis blog is a dedicated space where I document and share my learning journey, insights, and study recordings. From new concepts to detailed project explorations, you’ll find posts that reflect my growth and discoveries in various fields of study. Whether you’re following along or exploring similar paths, I hope you find value and inspiration in the records from my studies.\nFeel free to reach out via the fancy button below!"
  },
  {
    "objectID": "posts/python/python3.html",
    "href": "posts/python/python3.html",
    "title": "Sensitivity, Specificity, ROC Curve and AUC",
    "section": "",
    "text": "Sensitivity measures the proportion of positive results out of all truly positive samples. In other words, a test’s sensitivity is its ability to correctly identify those with the disease (the true positives) while minimizing the number of false negative results.\nSpecificity measures the proportion of negative test result out of all truly negative samples. In other words, a test’s specificity is its ability to correctly identify those without the disease (the true negatives) while minimizing false positive results.\nFalse results are also known as testing errors. The consequences of atesting error- a false positive or a false negative- are not equivalent.\nThe following is the so-called confusion matrix.\n\nMthematically: + Sensitivity = TP/(TP+FN) + Specificity = TN/(TN+FP)\n\n\n\nThe Receiver Operating Characteristic (ROC) curve is a graphical representation used to evaluate the performance of a binary classifier. When we have a sequence of predicted probabilities for two classes, we need to apply a threshold to classify them. Different thresholds lead to different classification results, and for each result, we can calculate sensitivity and specificity. The ROC curve is generated by plotting the true positive rate (TPR) against the false positive rate (FPR) (which is 1-specificity) for every possible threshold (or, more practically, at selected intervals). This provides a visual way to assess the trade-offs between TPR and FPR across varying threshold values.\nIn binary classification, class predictions for each instance are often based on a continuous random variable \\(X\\) , which represents a “score” computed for the instance (e.g., the estimated probability in logistic regression). The variable \\(X\\) indicates the likelihood of being classified as “positive”. Since we have two groups (true positives and true negatives), the distribution of \\(X\\) differs between these groups, with densities denoted as \\(f_1\\) for the positive class and \\(f_2\\) for the negative class.\nThe true True Positive Rate (TPR) at a threshold \\(T\\) is given by: \\[\nTPR(T) = \\int_{T}^\\infty f_1(x) , dx\n\\]\nSimilarly, the False Positive Rate (FPR) is expressed as: \\[\nFPR(T) = \\int_{T}^\\infty f_2(x) , dx\n\\]\nThe ROC curve is generated by plotting \\(TPR(T)\\) versus \\(FPR(T)\\) , with \\(T\\) as the varying parameter.\nThe following example comes from wikipedia\n\nimagine that the blood protein levels in diseased people and healthy people are normally distributed with means of 2 g/dL and 1 g/dL respectively. A medical test might measure the level of a certain protein in a blood sample and classify any number above a certain threshold as indicating disease. The experimenter can adjust the threshold (green vertical line in the figure), which will in turn change the false positive rate. Increasing the threshold would result in fewer false positives (and more false negatives), corresponding to a leftward movement on the curve. The actual shape of the curve is determined by how much overlap the two distributions have. \n\n\n\n\nAUC is the area under the curve. How to interpret it?\nIt is equal to the probability that a classifier will rank a randomly chosen positive instance higher than a randomly chosen negative one.\n\nIn other words, when given one randomly selected positive instance and one randomly selected negative instance, AUC is the probability that the classifier will be able to tell which one is which."
  },
  {
    "objectID": "posts/python/python3.html#definition",
    "href": "posts/python/python3.html#definition",
    "title": "Sensitivity, Specificity, ROC Curve and AUC",
    "section": "",
    "text": "Sensitivity measures the proportion of positive results out of all truly positive samples. In other words, a test’s sensitivity is its ability to correctly identify those with the disease (the true positives) while minimizing the number of false negative results.\nSpecificity measures the proportion of negative test result out of all truly negative samples. In other words, a test’s specificity is its ability to correctly identify those without the disease (the true negatives) while minimizing false positive results.\nFalse results are also known as testing errors. The consequences of atesting error- a false positive or a false negative- are not equivalent.\nThe following is the so-called confusion matrix.\n\nMthematically: + Sensitivity = TP/(TP+FN) + Specificity = TN/(TN+FP)\n\n\n\nThe Receiver Operating Characteristic (ROC) curve is a graphical representation used to evaluate the performance of a binary classifier. When we have a sequence of predicted probabilities for two classes, we need to apply a threshold to classify them. Different thresholds lead to different classification results, and for each result, we can calculate sensitivity and specificity. The ROC curve is generated by plotting the true positive rate (TPR) against the false positive rate (FPR) (which is 1-specificity) for every possible threshold (or, more practically, at selected intervals). This provides a visual way to assess the trade-offs between TPR and FPR across varying threshold values.\nIn binary classification, class predictions for each instance are often based on a continuous random variable \\(X\\) , which represents a “score” computed for the instance (e.g., the estimated probability in logistic regression). The variable \\(X\\) indicates the likelihood of being classified as “positive”. Since we have two groups (true positives and true negatives), the distribution of \\(X\\) differs between these groups, with densities denoted as \\(f_1\\) for the positive class and \\(f_2\\) for the negative class.\nThe true True Positive Rate (TPR) at a threshold \\(T\\) is given by: \\[\nTPR(T) = \\int_{T}^\\infty f_1(x) , dx\n\\]\nSimilarly, the False Positive Rate (FPR) is expressed as: \\[\nFPR(T) = \\int_{T}^\\infty f_2(x) , dx\n\\]\nThe ROC curve is generated by plotting \\(TPR(T)\\) versus \\(FPR(T)\\) , with \\(T\\) as the varying parameter.\nThe following example comes from wikipedia\n\nimagine that the blood protein levels in diseased people and healthy people are normally distributed with means of 2 g/dL and 1 g/dL respectively. A medical test might measure the level of a certain protein in a blood sample and classify any number above a certain threshold as indicating disease. The experimenter can adjust the threshold (green vertical line in the figure), which will in turn change the false positive rate. Increasing the threshold would result in fewer false positives (and more false negatives), corresponding to a leftward movement on the curve. The actual shape of the curve is determined by how much overlap the two distributions have. \n\n\n\n\nAUC is the area under the curve. How to interpret it?\nIt is equal to the probability that a classifier will rank a randomly chosen positive instance higher than a randomly chosen negative one.\n\nIn other words, when given one randomly selected positive instance and one randomly selected negative instance, AUC is the probability that the classifier will be able to tell which one is which."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html",
    "href": "posts/Rcpp study/Rcpp study.html",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "The following code shows the basic format for defining a Rcpp function.\n\n#include&lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nRETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){\n\n    //do something\n\n    return RETURN_VALUE;\n}\n\n\n#include&lt;Rcpp.h&gt; : This sentence enables us to use classes and functions defined by the Rcpp package\nusing namespace Rcpp; : this sentence enables us to use them directly, other wise you need to declare that we use these function from package Rcpp by, e.g. Rcpp::NumericVector.\n\n\n\n// [[Rcpp::export]]：The function defined just below this sentence will be accessible from R.\nRETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){}：We need to specify data types of functions and arguments.\n\n\n\n\nThe function Rcpp::sourceCpp() will compile your source code and load the defined function into R. The below code defines a function that calculates the sum of a vector.\n\n//sum.cpp\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector v){\n    double sum = 0;\n    for(int i=0; i&lt;v.length(); ++i){\n        sum += v[i];\n    }\n    return(sum);\n}\n\nNow we can load it into R by\n\nlibrary(Rcpp)\nsourceCpp('sum.cpp')\n\n\n\n\nWe can use our Rcpp functions as usual R functions\n\nrcpp_sum(1:10)\n#&gt; [1] 55\n\n\n\n\nWe can write Rcpp code in our R code in 3 ways.\n\n\nSave Rcpp code as string object in R and compile it with sourceCpp()\n\nsrc &lt;-\n\"#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector v){\n  double sum = 0;\n  for(int i=0; i&lt;v.length(); ++i){\n    sum += v[i];\n  }\n  return(sum);\n}\"\n\nsourceCpp(code = src)\nrcpp_sum(1:10)\n#&gt; [1] 55\n\n\n\n\nWe can omit #include &lt;Rcpp.h&gt; and using namespase Rcpp when we use cppFunction().\n\nsrc &lt;-\"double rcpp_sum(NumericVector v){\n    double sum = 0;\n    for(int i=0; i&lt;v.length(); ++i){\n      sum += v[i];\n    }\n    return(sum);\n  }\n  \"\nRcpp::cppFunction(src)\nrcpp_sum(1:10)\n#&gt; [1] 55\n\n\n\n\nYou can evaluate a single C++ statement by using evalCpp().\n\n# Showing maximum value of double.\nevalCpp('std::numeric_limits&lt;double&gt;::max()')\n#&gt; [1] 1.797693e+308\n\n\n\n\n\nC++ 11 is a standard of C++ newly established in 2011. Many new features have been added to make C++ even easier for beginners.\n\n\n\n\n\n\nImportant\n\n\n\nThe code examples in this document are written with C++11 enabled.\n\n\n\n\nTo enable C++11, add the following decription in our Rcpp code. &gt; // [[Rcpp::plugins(\"cpp11\")]]\n\n\n\n\n\n\n// Initialize Vector\n// The next three are the same as c (1, 2, 3).\nNumericVector v1 = NumericVector::create(1.0, 2.0, 3.0);\nNumericVector v2 = {1.0, 2.0, 3.0};\nNumericVector v3   {1.0, 2.0, 3.0}; // You can omit \"=\".\n\n\n\n\nBy using decltype, you can declare a variable of the same type as an existing variable.\n\nint i;\ndecltype(i) x; // variable \"x\" will be int\n\n\n\n\nWe can write a for statement with the same style as R.\n\nIntegerVector v {1,2,3};\nint sum=0;\nfor(auto& x : v) {\n  sum += x;\n}\n\n\nauto& x: The auto& keyword means that each element in the vector v will be referenced as x. Using & allows direct access to each element (by reference), but here it’s primarily for efficiency, so no copy of each element is made.\n\n\n\n\nIt is a function object created as an unnamed function and passed to the other function.\nLambda expressions are written in the form [](){}\n[] specifies how the lambda should access variables from the surrounding scope. Here are the different options:\n\n[] : Capture nothing. The lambda function cannot access any local variables from the surrounding scope.\n[=] : Capture all local variables by value. This means a copy of each variable is made, and the lambda works with the copy.\n[&] : Capture all local variables by reference. The lambda can modify the original variables because it’s accessing them directly.\n[=x, &y]: Capture specific variables in different ways. In this example, the variable x will be captured by value (copied), and y will be captured by reference (accessed directly).\n\nThe return type of this function object is automatically set to the type of the returned value described in {}. If you want to define return type explicitly, write it like []()-&gt;int{}.\nExamples\nR example\n\nv &lt;- c(1,2,3,4,5)\nA &lt;- 2.0\nsapply(v, function(x){A*x})\n#&gt; [1]  2  4  6  8 10\n\nRcpp example We save it as lambda.cpp\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::plugins(\"cpp11\")]]\n// [[Rcpp::export]]\nNumericVector rcpp_lambda_1(){\n  NumericVector v = {1,2,3,4,5};\n  double A = 2.0;\n  NumericVector res =\n    sapply(v, [&](double x){return A*x;});\n  return res;\n}\n\n\nsourceCpp('lambda.cpp')\nrcpp_lambda_1()\n#&gt; [1]  2  4  6  8 10\n\n\n\n\n\n\n\n\n\n// [[Rcpp::export]]\nvoid rcpp_rcout(NumericVector v){\n  // printing value of vector\n  Rcout &lt;&lt; \"The value of v : \" &lt;&lt; v &lt;&lt; \"\\n\";\n\n  // printing error message\n  Rcerr &lt;&lt; \"Error message\\n\";\n}\n\n\nThis line declares a function named rcpp_rcout that takes a NumericVector as an argument and returns nothing (void).\nRcout is an Rcpp-specific object similar to the standard C++ std::cout, but it is used for printing messages to the R console. It uses &lt;&lt; to concatenate output.\nRcerr is similar to the standard C++ std:cerr, which is used for error messages and diagnostic output. Rcerr is used to send error or warning messages in R, so output sent through Rcerr might be displayed differently (in red text, depending on the R environment) to indicate an issue or warning.\n\n\n\n\nThese functions are used to print formatted output to the R console. It allows you to format the output using placeholders (e.g., %d for integers, %f for floats).\nSyntax:\n\nRprintf( format, variables)\n\nThe first argument is a format string, and subsequent arguments are the values to be inserted into the formatted string. Some format specifier is presented below:\n\n\n\n\n\n\n\nspecifier\nexplanation\n\n\n\n\n%i\nprinting signed integer (int)\n\n\n%u\nprinting unsigned integer (unsigned int)\n\n\n%f\nprinting floating point number (double)\n\n\n%e\nprinting floating point number (double) in exponential style\n\n\n%s\nprinting C string (char*)\n\n\n\n\nAdditionally, Rprintf() and REprintf() can only print data types that exist in standard C++ language, thus you cannot pass data types defined by Rcpp package (such as NumericVector) to Rprintf() directly. If you want to print the values of elements of an Rcpp vector using Rprintf(), you have to pass each element separately to it (see below).\n\n\n// [[Rcpp::export]]\nvoid rcpp_rprintf(NumericVector v){\n    // printing values of all the elements of Rcpp vector  \n    for(int i=0; i&lt;v.length(); ++i){\n        Rprintf(\"the value of v[%i] : %f \\n\", i, v[i]);\n    }\n}\n\n\n\n\n\nAll the basic data types and data structures provided by R are available in Rcpp. By using these data types, you can directly access the objects that exist in R. ### Vector and Matrix Following seven data types are often used in R.\nlogical integer numeric complex character Date POSIXct ### Vector and matrix There are vector type and matrix types in Rcpp corresponding to those of R.\nThe table below presents the correspondence of data types between R/Rcpp/C++.\n\n\n\n\n\n\n\n\n\n\n\nValue\nR vector\nRcpp vector\nRcpp matrix\nRcpp scalar\nC++ scalar\n\n\n\n\nLogical\nlogical\nLogicalVector\nLogicalMatrix\n-\nbool\n\n\nInteger\ninteger\nIntegerVector\nIntegerMatrix\n-\nint\n\n\nReal\nnumeric\nNumericVector\nNumericMatrix\n-\ndouble\n\n\nComplex\ncomplex\nComplexVector\nComplexMatrix\nRcomplex\ncomplex\n\n\nString\ncharacter\nCharacterVector (StringVector)\nCharacterMatrix (StringMatrix)\nString\nstring\n\n\nDate\nDate\nDateVector\n-\nDate\n-\n\n\nDatetime\nPOSIXct\nDatetimeVector\n-\nDatetime\ntime_t\n\n\n\n\n\nOther than Vector and Matrix, There are several data structures in R such as data.frame, list, S3 class and S4 class. You can handle all of these data structures in Rcpp.\n\n\n\nR\nRcpp\n\n\n\n\ndata.frame\nDataFrame\n\n\nlist\nList\n\n\nS3 class\nList\n\n\nS4 class\nS4\n\n\n\nIn Rcpp, Vector, DataFrame, List are all implemented as kinds of vectors. Namely, Vector is a vector that its elements are scalar values, DataFrame is a vector that its elements are Vectors, List is a vector that its elements are any kind of data types. Thus, Vector, DataFrame, List has many common member functions in Rcpp.\n\n\n\n\n\n\nWe can create vector objects in several ways.\n\n// Create a Vector object equivalent to\n// v &lt;- rep(0, 3)\nNumericVector v (3);\n\n// v &lt;- rep(1, 3)\nNumericVector v (3,1);\n\n// v &lt;- c(1,2,3) \n// C++11 Initializer list\nNumericVector v = {1,2,3}; \n\n// v &lt;- c(1,2,3)\nNumericVector v = NumericVector::create(1,2,3);\n\n// v &lt;- c(x=1, y=2, z=3)\nNumericVector v =\n  NumericVector::create(Named(\"x\",1), Named(\"y\")=2 , _[\"z\"]=3);\n\n\n\n\nThis Rcpp function demonstrates various ways of accessing and modifying elements of a NumericVector in R using different types of indices (numerical, integer, character, and logical).\n\n// [[Rcpp::export]]\nvoid rcpp_vector_access() {\n  // Creating vector\n  NumericVector v  {10, 20, 30, 40, 50};\n\n\nA NumericVector v is created with five numeric elements: {10, 20, 30, 40, 50}.\n\n\n\n  // Setting element names\n  v.names() = CharacterVector({\"A\", \"B\", \"C\", \"D\", \"E\"});\n\n\nThis sets the names for the elements in the NumericVector v. After this, the vector looks like:\n\n\nA  B  C  D  E \n10 20 30 40 50\n\n\n  // Preparing vector for access\n  NumericVector numeric = {1, 3};\n  IntegerVector integer = {1, 3};\n  CharacterVector character = {\"B\", \"D\"};\n  LogicalVector logical = {false, true, false, true, false};\n\n\nThese vectors (numeric, integer, character, and logical) are created for indexing:\n\n\n\n  // Getting values of vector elements\n  double x1 = v[0];             // Accesses the first element (10)\n  double x2 = v[\"A\"];           // Accesses the element with name \"A\" (also 10)\n  NumericVector res1 = v[numeric];    // Gets elements at indices 2 and 4 (20, 40)\n  NumericVector res2 = v[integer];    // Same as res1 (20, 40)\n  NumericVector res3 = v[character];  // Gets elements named \"B\" and \"D\" (20, 40)\n  NumericVector res4 = v[logical];    // Gets elements at positions 2 and 4 (20, 40)\n\n\n\nv[0]: Accesses the first element using numeric indexing (zero-based indexing in C++).\nv[“A”]: Accesses the element with the name “A”, which corresponds to the first element (10).\nv[numeric], v[integer], v[character], v[logical]: Accesses multiple elements at once using vectors of different types (numeric, integer, character, logical). All of these access the same elements, 20 and 40, but using different methods of indexing.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nwhen accessing elements from a container like NumericVector in Rcpp, you typically need to declare the type of the variable that will hold the result first.\n\n\n\n\n  // Assigning values to vector elements\n  v[0]   = 100;                 // Replaces the first element with 100\n  v[\"A\"] = 100;                 // Replaces the element named \"A\" with 100\n  NumericVector v2 {100, 200};   // A new vector {100, 200}\n  v[numeric]   = v2;            // Replaces elements at indices 2 and 4 with 100, 200\n  v[integer]   = v2;            // Same as above (2nd and 4th elements)\n  v[character] = v2;            // Replaces elements named \"B\" and \"D\" with 100, 200\n  v[logical]   = v2;            // Replaces elements at logical `true` positions (2nd and 4th) with 100, 200\n}\n\n\n\nv[0] = 100: Changes the first element to 100.\nv[\"A\"] = 100: Changes the element named “A” (which is the same as the first element) to 100.\nv[numeric] = v2, v[integer] = v2, v[character] = v2, v[logical] = v2: These lines replace the selected elements (based on various indexing methods) with the values from the new vector v2 ({100, 200}).\n\n\n\n\n\n\n\n\nImportant\n\n\n\nwhen modifying elements of a vector or container in Rcpp, you must ensure that the new elements are of the same type as the original container.\n\n\n\n\n\nMethods are functions that are attached to an individual object. You can call methods function f() of object v in the form v.f().\n\nNumericVector v = {1,2,3,4,5};\n\n// Calling member function\nint n = v.length(); // 5\n\nThe vector object in Rcpp has methods functiongs listed below\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nsize()\nReturns the number of elements of this vector object.\n\n\nnames()\nReturns the element names of this vector object as CharacterVector.\n\n\noffset(name), findName(name)\nReturns the numerical index of the element specified by the character string name.\n\n\noffset(i)\nReturns the numerical index of the element specified by the numerical index i after bounds check.\n\n\nfill(x)\nFills all the elements of this vector object with scalar value x.\n\n\nsort()\nReturns a vector that sorts this vector object in ascending order.\n\n\nassign(first_it, last_it)\nAssigns values specified by the iterator first_it and last_it to this vector object.\n\n\npush_back(x)\nAppends a scalar value x to the end of this vector object.\n\n\npush_back(x, name)\nAppends a scalar value x to the end of this vector object and sets the name of the element as name.\n\n\npush_front(x)\nAppends a scalar value x to the front of this vector object.\n\n\npush_front(x, name)\nAppends a scalar value x to the front of this vector object and sets the name of the element as name.\n\n\nbegin()\nReturns an iterator pointing to the first element of this vector object.\n\n\nend()\nReturns an iterator pointing to the end (one past the last element) of this vector object.\n\n\ncbegin()\nReturns a const iterator pointing to the first element of this vector.\n\n\ncend()\nReturns a const iterator pointing to the end (one past the last element) of this vector.\n\n\ninsert(i, x)\nInserts a scalar value x at the position specified by the numerical index i.\n\n\ninsert(it, x)\nInserts a scalar value x at the position pointed to by the iterator it.\n\n\nerase(i)\nErases the element at the position specified by the numerical index i.\n\n\nerase(it)\nErases the element at the position pointed to by the iterator it.\n\n\nerase(first_i, last_i)\nErases elements from the position specified by numerical index first_i to last_i.\n\n\nerase(first_it, last_it)\nErases elements from the position specified by the iterators first_it to last_it.\n\n\ncontainsElementNamed(name)\nReturns true if this vector contains an element with the name specified by the character string name.\n\n\n\n\n\n\nA static methods is a function that belongs to a class rather than an instance of the class. This means that you don’t need to create an object (or instance) of the class to call the function; you can call it directly using the class name.\n\nStatic member functions are called using the class name followed by the ::\nExample in Rcpp: NumericVector::create(). Here, create() is a static member function of the class NumericVector, which means you can call it directly using the class name (NumericVector), without creating a NumericVector object first.\n\n\n\n\n\nMatrix objects can be created in several ways.\n\n// Create a Matrix object equivalent to\n// m &lt;- matrix(0, nrow=2, ncol=2)\nNumericMatrix m1( 2 );\n\n// m &lt;- matrix(0, nrow=2, ncol=3)\nNumericMatrix m2( 2 , 3 );\n\n// m &lt;- matrix(v, nrow=2, ncol=3)\nNumericMatrix m3( 2 , 3 , v.begin() );\n\nIn addition, a matrix object in R is actually a vector that the number of rows and columns are set in the attribute dim.\nThus, if you create a vector with attribute dim in Rcpp and return it to R, it will be treated as a matrix.\n\nmat &lt;- '#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::export]]\nNumericVector rcpp_matrix(){\n    // Creating a vector object\n    NumericVector v = {1,2,3,4};\n\n    // Set the number of rows and columns to attribute dim of the vector object.\n    v.attr(\"dim\") = Dimension(2, 2);\n\n    // Return the vector to R\n    return v;\n}'\nsourceCpp(code=mat)\nrcpp_matrix()\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    3\n#&gt; [2,]    2    4\n\n\nEven if you set a value to attribute dim of a Vector object, the type of the object remains a Vector type in Rcpp code. Thus, if you want to convert it to Matrix type in Rcpp, you need to use as&lt;T&gt;() function.\n\n\n// Set number of rows and columns to attribute dim\nv.attr(\"dim\") = Dimension(2, 2);\n\n// Converting to Rcpp Matrix type\nNumericMatrix m = as&lt;NumericMatrix&gt;(v);\n\n\n\nBy using the () operator, you can get from and assign to the values of elements of a Matrix object by specifying its column number and row number.\n\n// Creating a 5x5 numerical matrix\nNumericMatrix m( 5, 5 );\n\n// Retrieving the element of row 0 and column 2\ndouble x = m( 0 , 2 );\n\n\n\nThis line retrieves the element at row 0, column 2 of the matrix m and stores it in the variable x.\nThe parentheses m(0, 2) are used for element access in the matrix, similar to m[0, 2] in R.\n\n\n\nNumericVector v = m( 0 , _ );\n\n\n\nThis line copies all the values in row 0 (i.e., the entire first row) of the matrix m into the vector v.\nThe underscore _ is a placeholder that represents “all elements” in the corresponding dimension.\n\n\n\nNumericVector v = m( _ , 2 );\n\n\n\nThis line copies all the values in column 2 (i.e., the third column) of the matrix m into the vector v.\n\n\n\nNumericMatrix m2 = m( Range(0,1), Range(2,3) );\n\n\n\nThis line copies a submatrix of m consisting of the values in rows 0 and 1 (first and second rows) and columns 2 and 3 (third and fourth columns) into a new matrix m2. Range(0,1) specifies that rows 0 and 1 should be selected, and Range(2,3) specifies that columns 2 and 3 should be selected.\n\n\n\nm[5]; // This points to the same element as m(0,1)\n\n\nThis line demonstrates linear indexing into the matrix. While NumericMatrix is a two-dimensional structure, it can also be treated like a 1D array when accessed with square brackets [].\n\n\n\n\nRcpp also provides types that hold “references” to specific parts of a matrix.\n\nReferencing a Column:\n\n\nNumericMatrix::Column col = m( _ , 1 );\n\n\n\nm(_, 1): This accesses column 1 of the matrix m (zero-based indexing, so it refers to the second column).\nNumericMatrix::Column: This type is a reference to a specific column of the matrix. It doesn’t create a copy of the column but rather provides direct access to the elements in column 1.\n\n\n\nReferencing a Row:\n\n\nNumericMatrix::Row row = m( 1 , _ );\n\n\n\nm(1,_): Thisaccesses row 1 of the matrix m\nNumericMatrix::Row: This type is a reference to a specific row of the matrix.\n\n\n\nReferencing a Submatrix\n\n\nNumericMatrix::Sub sub = m( Range(0,1) , Range(2,3) );\n\n\n\nRange(0,1): This specifies the range of rows to select (rows 0 and 1, the first two rows).\nRange(2,3): This specifies the range of columns to select (columns 2 and 3, the third and fourth columns).\nNumericMatrix::Sub: This type is a reference to a submatrix of m. It references the elements in the submatrix defined by the row and column ranges.\n\n\n\n\n\nSince Matrix is actually Vector, Matrix basically has the same member functions as Vector. Thus, member functions unique to Matrix are only presented below.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nnrow() or rows()\nReturns the number of rows.\n\n\nncol() or cols()\nReturns the number of columns.\n\n\nrow(i)\nReturns a reference Vector::Row to the i-th row.\n\n\ncolumn(i)\nReturns a reference Vector::Column to the i-th column.\n\n\nfill_diag(x)\nFills the diagonal elements with the scalar value x.\n\n\noffset(i, j)\nReturns the numerical index in the original vector of the matrix corresponding to the element at row i and column j.\n\n\n\n\n\n\nMatrix basically has the same static member function as Vector. The static member functions unique to Matrix are shown below. Matrix::diag( size, x ): Returns a diagonal matrix whose number of rows and columns equals to “size” and the value of the diagonal element is “x”.\n\ncppFunction(\"\nNumericMatrix create_diag_matrix(int size, double x) {\n    // Create a diagonal matrix of the given size with x on the diagonal\n    NumericMatrix mat = NumericMatrix::diag(size, x);\n    return mat;\n}\")\ncreate_diag_matrix(5,2)\n\n\n\n\n\n\n\nImportant\n\n\n\nx is a scalar value that will be placed along the diagonal of the matrix.\n\n\n\n\n\n\nrownames\n\n\nget the row name of matrix m:\n\n\nCharacterVector ch = rownames(m);\n\n\nset the row name of matrix m:\n\n\nrownames(m) = ch\n\n\ncolnames\n\n\nget the column name of matrix m:\n\n\nCharacterVector ch = colnames(m);\n\n\nset the column name of matrix m:\n\n\ncolnames(m) = ch\n\n\ntranspose return the transposed matrix of matirx m:\n\n\ntranspose(m)\n\n\n\n\n\n\n\nBy using the + - * / operator you can perform elementwise arithmetic operations between vectors of the same length.\n\nNumericVector x ;\nNumericVector y ;\n\nVector and vector operation\n\n// Vector and vector operation\nNumericVector res = x + y ;\nNumericVector res = x - y ;\nNumericVector res = x * y ;\nNumericVector res = x / y ;\n\nVector and scalar operation\n\n// Vector and scalar operation\nNumericVector res = x   + 2.0 ;\nNumericVector res = 2.0 - x;\nNumericVector res = y   * 2.0 ;\nNumericVector res = 2.0 / y;\n\nExpression and expression operation\n\nNumericVector res = x * y + y / 2.0 ;\nNumericVector res = x * ( y - 2.0 ) ;\nNumericVector res = x / ( y * y ) ;\n\nThe - operator inverts the sign.\n\nNumericVector res = -x ;\n\n\n\n\nComparison of vectors using == ! = &lt; &gt; &gt;= &lt;= operators produces logical vectors. You can also access vector elements using logical vectors.\nComparison of vector and vector\n\nLogicalVector res = x &lt; y ;\nLogicalVector res = x &gt; y ;\nLogicalVector res = x &lt;= y ;\nLogicalVector res = x &gt;= y ;\nLogicalVector res = x == y ;\nLogicalVector res = x != y ;\n\nComparison of vector and scalar\n\nLogicalVector res = x &lt; 2 ;\nLogicalVector res = 2 &gt; x;\nLogicalVector res = y &lt;= 2 ;\nLogicalVector res = 2 != y;\n\nComparison of expression and expression\n\nLogicalVector res = ( x + y ) &lt; ( x*x ) ;\nLogicalVector res = ( x + y ) &gt;= ( x*x ) ;\nLogicalVector res = ( x + y ) == ( x*x ) ;\n\n!(...): The logical NOT operator ! negates the result of the comparison. In other words, it turns TRUE into FALSE and FALSE into TRUE.\n\nLogicalVector res = !(x &lt; y);\n\nAccessing the elements of the vector using logical vectors.\n\nNumericVector res = x[x &lt; 2];\n\n\n\n\n\n\n\nAlthough in C++ the boolean type (bool) has only two possible values, true (1) and false (0), R’s logical vectors have a third possible value: NA (missing or undefined). Because C++ bool can’t represent this third state, Rcpp uses integers to represent the elements of R’s LogicalVector.\nIn Rcpp, elements of a LogicalVector are stored as integers to accommodate the extra NA value. Specifically, these values are represented as: + TRUE: 1 (same as C++ true) + FALSE: 0 (same as C++ false) + NA: NA_LOGICAL, which is a special constant defined as the minimum value of an integer: -2147483648 (the smallest value for a 32-bit signed integer).\n\n\n\nUse the operator & (logical product) | (logical sum) ! (Logical negation) for the logical operation for each element of LogicalVector.\n\nLogicalVector v1 = {1,1,0,0};\nLogicalVector v2 = {1,0,1,0};\n\nLogicalVector res1 = v1 & v2;\nLogicalVector res2 = v1 | v2;\nLogicalVector res3 = !(v1 | v2);\n\nRcout &lt;&lt; res1 &lt;&lt; \"\\n\"; // 1 0 0 0\nRcout &lt;&lt; res2 &lt;&lt; \"\\n\"; // 1 1 1 0\nRcout &lt;&lt; res3 &lt;&lt; \"\\n\"; // 0 0 0 1\n\n\n\n\n\n\nExamples of functions that receive LogicalVector are all(), any() and ifelse().\n\nall(v) returns TRUE when all elements of v are TRUE, and any(v) returns TRUE if any of v’s elements are TRUE.\n\nIn Rcpp, the return type of both all() and any() is not a simple bool, but a more complex type called SingleLogicalResult.\nThis type can represent not only TRUE or FALSE, but also NA (the third possible logical value in R). As a result, the return value of all() or any() cannot be directly used in a conditional statement like an if statement in C++.\nTo convert the SingleLogicalResult from all() or any() into a bool, Rcpp provides helper functions: + is_true(): Returns true if the result is TRUE. + is_false(): Returns true if the result is FALSE. + is_na(): Returns true if the result is NA.\n\n\n\nifelse (v, x1, x2) receives the logical vector v, and returns the corresponding element of x1 when the element of v is TRUE and the corresponding element of x2 when it is FALSE.\n\nx1 and x2 must either be scalars or vectors. If they are vectors, their length must match the length of v. This ensures that there is a corresponding element in x1 or x2 for each element in v.\n\n\nNumericVector v1;\nNumericVector v2;\n//Number of elements of vector\nint n = v1.length();\n\nIn case, both x1 and x2 are scalar\n\nIntegerVector res1     = ifelse( v1&gt;v2, 1, 0);\nNumericVector res2     = ifelse( v1&gt;v2, 1.0, 0.0);\n\n\n\n\n\n\n\nImportant\n\n\n\nSince ifelse() does not work with a scalar character string, we need to use a string vector whose values of elements are all the same.\n\n\n\nCharacterVector chr_v1 = rep(CharacterVector(\"T\"), n);\nCharacterVector chr_v2 = rep(CharacterVector(\"F\"), n);\nCharacterVector res3   = ifelse( v1&gt;v2, chr_v1, chr_v2);\n\nIn case, x1 and x2 are vector and scalar\n\nIntegerVector res4 = ifelse(v1 &gt; v2, int_v1, 0);\nNumericVector res5 = ifelse(v1 &gt; v2, num_v1, 0.0);\nCharacterVector res6 = ifelse(v1 &gt; v2, chr_v1, Rf_mkChar(\"F\")); // Note\n\n\n\nFor integer and numeric vectors, the scalar values (0 and 0.0) are recycled as needed\nFor character vectors, you cannot directly use a scalar string like \"F\"; instead, you use Rf_mkChar(\"F\"), which creates an internal SEXP (R object) representing the string “F”.\n\n\n\n\n\n\n\n\n\nIn Rcpp, DataFrame is implemented as a kind of vector. In other words, Vector is a vector whose element is scalar value, while DataFrame is a vector whose elements are Vectors of the same length.\nDataFrame::create() is used to create a DataFrame object.\n\n// Creating DataFrame df from Vector v1, v2\nDataFrame df = DataFrame::create(v1, v2);\n\nAlso, use Named() or _[] if you want to specify column names when creating DataFrame　object.\n\n// When giving names to columns\nDataFrame df = DataFrame::create( Named(\"V1\") = v1 , _[\"V2\"] = v2 );\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen you create a DataFrame with DataFrame::create(), the value of the originalVector element will not be duplicated in the columns of the DataFrame, but the columns will be the “reference” to the original Vector. Therefore, changing the value of the original Vector changes the value of the columns. To avoid this, use clone().\n\n\n\ndf &lt;- '#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::export]]\nDataFrame rcpp_df(){\n  // Creating vector v\n  NumericVector v = {1,2};\n  // Creating DataFrame df\n  DataFrame df = DataFrame::create( Named(\"V1\") = v,         // simple assign\n                                    Named(\"V2\") = clone(v)); // using clone()\n  // Changing vector v\n  v = v * 2;\n  return df;\n}'\nsourceCpp(code=df)\nrcpp_df()\n\n\n\n\nWhen you access a specific column of a DataFrame in Rcpp, that column is temporarily assigned to a Vector object. The Vector object allows you to manipulate or access the values of that column as if it were a separate vector.\n\n\n\n\n\n\nWarning\n\n\n\nAs with DataFrame creation, assigning aDataFrame column to Vector in the above way will not copy the column value to Vector object, but it will be a “reference” to the column. Therefore, when you change the values of Vector object, the content of the column will also be changed.\n\n\n\n\nYou can specify which column of the DataFrame you want to access using different types of vectors:\n\nNumeric Vector (Column Number):You can specify a column by its index (0-based). Example: df[0] would return the first column.\nString Vector (Column Name):You can access a column by its name using a string, which is more intuitive and readable when dealing with named columns.\nLogical Vector: Each element of the logical vector corresponds to whether a column should be included (TRUE) or excluded (FALSE). The length of the logical vector must match the number of columns in the data frame.\n\n\n\n\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nnrows()\nReturns the number of rows.\n\n\nncol()\nReturns the number of columns.\n\n\nlength()\nReturns the number of columns.\n\n\nsize()\nReturns the number of columns.\n\n\nnames()\nReturns the column names as a CharacterVector.\n\n\noffset(name) or findName(name)\nReturns the numerical index of the column with the name specified by the string name.\n\n\nfill(v)\nFills all the columns of this DataFrame with the Vector v.\n\n\nassign(first_it, last_it)\nAssigns columns in the range specified by the iterators first_it and last_it to this DataFrame.\n\n\npush_back(v)\nAdds Vector v to the end of the DataFrame.\n\n\npush_back(v, name)\nAppends a Vector v to the end of the DataFrame and specifies the name of the added column with the string name.\n\n\npush_front(x)\nAppends a Vector v at the beginning of this DataFrame.\n\n\npush_front(x, name)\nAppends a Vector v at the beginning of this DataFrame and specifies the name of the added column with the string name.\n\n\nbegin()\nReturns an iterator pointing to the first column of this DataFrame.\n\n\nend()\nReturns an iterator pointing to the end of this DataFrame.\n\n\ninsert(it, v)\nAdds Vector v to this DataFrame at the position pointed by the iterator it and returns an iterator to that element.\n\n\nerase(i)\nDeletes the i-th column of this DataFrame and returns an iterator to the column just after the erased column.\n\n\nerase(it)\nDeletes the column specified by the iterator it and returns an iterator to the column just after the erased column.\n\n\nerase(first_i, last_i)\nDeletes columns from first_i to last_i - 1 and returns an iterator to the column just after the erased columns.\n\n\nerase(first_it, last_it)\nDeletes the range of columns specified by the iterators first_it to last_it - 1 and returns an iterator to the column just after the erased columns.\n\n\ncontainsElementNamed(name)\nReturns true if this DataFrame has a column with the name specified by the string name.\n\n\ninherits(str)\nReturns true if the attribute “class” of this object contains the string str.\n\n\n\n\n\n\n\nIn Rcpp, List is implemented as a kind of vector. In other words, Vector is a vector whose element is scalar value, while List is a vector whose elements are any kinds of data types.\n\n\nTo create a List object we use the List::create() function. Also, to specify the element name when creating List, use Named() function or _[].\n\n// Create list L from vector v1, v2\nList L = List::create(v1, v2);\n\n// When giving names to elements\nList L = List::create(Named(\"name1\") = v1 , _[\"name2\"] = v2);\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen you create a List with DataFrame::create(), the value of the originalVector element will not be duplicated but the elements will be the “reference” to the original Vector. Therefore, changing the value of the original Vector changes the value of the list. To avoid this, use clone().\n\n\n\n\n\nWhen accessing a specific element of List, we assign it to the other object and access it via that object.\nThe elements of List can be specified by numerical index, element names and logical vector.\n\n\n\nList has the same member functions as Vector\n\n\n\n\nThe S3 class is actually a list whose attribute class has its own value.\nWe use an example to demonstrate how to use it in Rcpp\n\ndouble rcpp_rmse(List lm_model) {\n    // Since S3 is a list, data type of the argument is specified as List.\n\n\nS3 objects in R, such as objects created by lm(), are typically lists with an additional class attribute. Since an S3 object is fundamentally a list, in Rcpp, we can use the List data type to receive it.\n\n\nif (! lm_model.inherits(\"lm\")) stop(\"Input must be a lm() model object.\");\n\n\nThe inherits(\"lm\") function checks whether the input object (the list) belongs to the lm class. This ensures that the input object is an lm object.\n\n\n    // Extracting residuals (i.e. actual - prediction) from the S3 object\n    NumericVector resid  = lm_model[\"residuals\"];\n\n\n\nIn an lm object, residuals are stored in the “residuals” component.\nSince the S3 object is a list, we can access the “residuals” component using list-like indexing (lm_model[“residuals”]), which extracts the residuals as a NumericVector in Rcpp.\n\n\n\n    // Number of elements of the residual vector\n    R_xlen_t n = resid.length();\n\n\n\nThe length() function is used to get the number of elements in the resid vector (i.e., the number of residuals).\nR_xlen_t is a type that represents the length of vectors in R. It is typically used in Rcpp when dealing with vector lengths.\n\n\n\nR_xlen_t is large enough to handle very long vectors, which is crucial when you’re working with vectors whose length might exceed the range of a standard integer (which is 2^31 - 1 in R, roughly 2 billion).\n\n\n    // The sum of squares of the residual vector\n    double rmse(0.0);\n    for(double& r : resid){\n        rmse += r*r;\n    }\n\n    // Divide the residual sum of squares by the number of elements and take the square root\n    return(sqrt((1.0/n)*rmse));\n}\n\n\n\nwait to update.\n\n\n\n\nString is a scalar type corresponding to the element of CharacterVector. String can also handle NA values (NA_STRING) which are not supported by the C character string char* and the C++ string std::string.\n\n\nThere are three main ways to create a String object. Each approach reflects different sources for creating the String object:\n\nCreating a String from a C/C++ String (Character Pointer or std::string):\n\n\n// Create String from C-style string\nString s1 = \"Hello, world!\";\n\n// Create String from std::string\nstd::string cpp_str = \"C++ string\";\nString s2 = cpp_str;\n\n\n\ns1 is created from a C-style string (\"Hello, world!\").\ns2 is created from a C++ string (std::string).\n\n\n\nCreating a String from Another String Object:\n\n\nYou can create a new String object by copying an existing String object in Rcpp.\n\n\nString s1 = \"Original string\";\n\n// Create a new String from another String object\nString s2 = s1;\n\n\nCreating a String from an Element of a CharacterVector:\n\n\nCharacterVector cv = CharacterVector::create(\"one\", \"two\", \"three\");\n\n// Create a String from the second element of the CharacterVector\nString s = cv[1];  // Note: 0-based indexing, so this accesses \"two\"\n\n\n\n\nIn Rcpp, the String class supports the += operator, which allows you to append another string (or string-like object) to an existing String object.\n\n// Creating String object\nString s(\"A\");\n\n// Conbining a string\ns += \"B\";\n\nRcout &lt;&lt; s &lt;&lt; \"\\n\"; \n// \"AB\"\n\n\n\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nreplace_first(str, new_str)\nReplace the first substring that matches the string str with the string new_str.\n\n\nreplace_last(str, new_str)\nReplace the last substring that matches the string str with the string new_str.\n\n\nreplace_all(str, new_str)\nReplace all substrings that match the string str with the string new_str.\n\n\npush_back(str)\nCombine the string str to the end of this String object. (Same as += operator)\n\n\npush_front(str)\nCombine the string str at the beginning of this String object.\n\n\nset_na()\nSet NA value to this String object.\n\n\nget_cstring()\nConvert the string of this String object into a C character string constant (const char*) and return it.\n\n\nget_encoding()\nReturns the character encoding. The encoding is represented by cettype_t.\n\n\nset_encoding(enc)\nSet the character encoding specified by cettype_t.\n\n\n\n\n\n\n\n\n\nThe following codes illustrates different ways to create a Date object in Rcpp, representing a specific date.\n\nDate d;  // \"1970-01-01\"\n\n\n\nDate d; creates a Date object d that represents the epoch date “1970-01-01”, which is considered the default starting point for dates in many computing systems, including R.\n\n\n\nDate d(1);  // \"1970-01-01\" + 1 day\n\n\n\nDate d(1); creates a Date object d that represents one day after the epoch date.\n\n\n\nDate d(1.1);  // \"1970-01-01\" + ceil(1.1) day\n\n\n\nDate d(1.1); creates a Date object d that represents 1.1 days after “1970-01-01”. The number is rounded up (using ceil()), so it is treated as 2 days after “1970-01-01”.\n\n\n\nDate d(\"2000-01-01\", \"%Y-%m-%d\");  // Date specified by a string with a format\n\n\nThis creates a Date object d from a string \"2000-01-01\" with the format \"%Y-%m-%d\"\n\nDate from Day, Month, and Year (mm/dd/yyyy):\n\nDate d(1, 2, 2000);  // 2000-01-02 (mon, day, year)\n\n\n\n\nDate has operators +, -, &lt;, &gt;, &gt;=, &lt;=, ==, !=.\nBy using these operators, you can perform addition of days (+), difference calculation of date (-), and comparison of dates (&lt;, &lt;=, &gt;, &gt;=, ==, !=) . ### Member functions\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nformat()\nReturns the date as a std::string using the same specification as base R. The default format is YYYY-MM-DD.\n\n\ngetDay()\nReturns the day of the date.\n\n\ngetMonth()\nReturns the month of the date.\n\n\ngetYear()\nReturns the year of the date.\n\n\ngetWeekday()\nReturns the day of the week as an int. (1:Sun, 2:Mon, 3:Tue, 4:Wed, 5:Thu, 6:Sat).\n\n\ngetYearday()\nReturns the number of the date through the year (with January 1st as 1 and December 31st as 365).\n\n\nis_na()\nReturns true if this object is NA.\n\n\n\n\n\n\nIn Rcpp, both DateVector and DateTimeVector are internally stored as numeric types (specifically, doubles). This design simplifies certain internal calculations but can be confusing when working with individual elements of these vectors.\nThis behavior is important because when you subset a DateVector using the [] operator, you extract a double, which represents the date as the number of days since the epoch date (1970-01-01).\nTo work with individual Date or DateTime objects from a DateVector or DateTimeVector, you need to explicitly cast or convert the extracted element back into a Date or DateTime object.\nExample:\n\n// [[Rcpp::export]]\nvoid print_year_of_date(DateVector dates) {\n    for (int i = 0; i &lt; dates.size(); ++i) {\n        // Convert the extracted double to a Date object\n        Date single_date = dates[i];  // Convert double to Date\n        int year = single_date.getYear();  // Now you can call getYear()\n        Rcpp::Rcout &lt;&lt; \"Year: \" &lt;&lt; year &lt;&lt; std::endl;\n    }\n}\n\n\n\ndates[i] returns a double by default.\nDate single_date = dates[i];: We explicitly convert the double value to a Date object, allowing us to use the getYear() method.\n\n\n\n\n\n\nThe RObject type in Rcpp is a flexible and general-purpose type that can represent any kind of R object.\nHere is an example that demonstrates how RObject can be used in Rcpp to accept and handle different types of R objects.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nvoid handle_any_type(RObject obj) {\n    // Check if the object is a NumericVector\n    if (obj.is&lt;NumericVector&gt;()) {\n        NumericVector num_vec = as&lt;NumericVector&gt;(obj);\n        Rcpp::Rcout &lt;&lt; \"Numeric Vector: \" &lt;&lt; num_vec &lt;&lt; std::endl;\n    } \n    // Check if the object is a CharacterVector\n    else if (obj.is&lt;CharacterVector&gt;()) {\n        CharacterVector char_vec = as&lt;CharacterVector&gt;(obj);\n        Rcpp::Rcout &lt;&lt; \"Character Vector: \" &lt;&lt; char_vec &lt;&lt; std::endl;\n    } \n    // Check if the object is a List\n    else if (obj.is&lt;List&gt;()) {\n        List lst = as&lt;List&gt;(obj);\n        Rcpp::Rcout &lt;&lt; \"List: \" &lt;&lt; lst &lt;&lt; std::endl;\n    } \n    // Handle unknown types\n    else {\n        Rcpp::Rcout &lt;&lt; \"Unknown type!\" &lt;&lt; std::endl;\n    }\n}\n\n\n\n\nas&lt;&gt;() is a template function in Rcpp that allows you to convert an RObject to a more specific type when you know the type of the object or have determined it dynamically.\n\n\nNumericVector num_vec = as&lt;NumericVector&gt;(obj);  // Convert RObject to NumericVector\n\n\nThis converts the RObject into a NumericVector when you are sure that it contains a numeric vector.\n\n\n\n\n\n\n\nIn Rcpp, when you assign an object (like a vector, list, or matrix) v1 to another object v2 using the = operator (e.g., v2 = v1;), no deep copy is made. Instead, v2 becomes an alias to v1, meaning that both v1 and v2 point to the same underlying data in memory.\nIf you want v2 to be a completely independent copy of v1, so that changes to v1 do not affect v2, you need to perform a deep copy. In Rcpp, you can use the clone() function to create a deep copy.\n\n\n\nYou should use R_xlen_t as data type for numerical index or the number of elements to support long vector in your Rcpp code.\n\n\n\nIn Rcpp, when you access an element of a vector with [] or (), you do not directly get the element as its native type (e.g., double, int, or String). Instead, you get a Vector::Proxy object. This Proxy object acts as an intermediary that allows you to modify the vector element directly or retrieve its value, but it is not the same as the element’s actual type.\nTo resolve this, you either: + Assign v[i] to a new object of the expected type. + Convert the Proxy to the native type using as&lt;T&gt;().\n\n\n\n\nHere is a list of Rcpp functions similar to R functions.\nIf you know for certain that your vector does not contain any NA values, you can optimize your code by using the noNA() function. noNA() marks the vector as guaranteed to be free of NA values, which allows Rcpp to skip NA checks and perform calculations more efficiently.\n\nList is too long to illustrate.\n\n\n\n\nIn Rcpp, probability distribution functions exist in two different namespaces:\n\nRcpp:: namespace:\n\n\nFunctions in this namespace return vectors.\nThese functions are designed to be similar to their counterparts in base R. You can pass a vector of values to these functions and they will return a vector of results.\n\n\nR:: namespace:\n\n\nFunctions in this namespace return scalar values (a single value).\nIf you only need a single value from the distribution function, using the R:: version of the function can be more efficient because it avoids the overhead of vectorization.\n\n\nsort_cpp &lt;- '#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::export]]\nNumericVector sort_numeric_vector(NumericVector x) {\n    std::sort(x.begin(), x.end());\n    return x;\n}'\nsourceCpp(code=sort_cpp)"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#format-for-defining-a-function-in-rcpp",
    "href": "posts/Rcpp study/Rcpp study.html#format-for-defining-a-function-in-rcpp",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "The following code shows the basic format for defining a Rcpp function.\n\n#include&lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nRETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){\n\n    //do something\n\n    return RETURN_VALUE;\n}\n\n\n#include&lt;Rcpp.h&gt; : This sentence enables us to use classes and functions defined by the Rcpp package\nusing namespace Rcpp; : this sentence enables us to use them directly, other wise you need to declare that we use these function from package Rcpp by, e.g. Rcpp::NumericVector.\n\n\n\n// [[Rcpp::export]]：The function defined just below this sentence will be accessible from R.\nRETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){}：We need to specify data types of functions and arguments."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#compiling-the-code",
    "href": "posts/Rcpp study/Rcpp study.html#compiling-the-code",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "The function Rcpp::sourceCpp() will compile your source code and load the defined function into R. The below code defines a function that calculates the sum of a vector.\n\n//sum.cpp\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector v){\n    double sum = 0;\n    for(int i=0; i&lt;v.length(); ++i){\n        sum += v[i];\n    }\n    return(sum);\n}\n\nNow we can load it into R by\n\nlibrary(Rcpp)\nsourceCpp('sum.cpp')"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#executing-the-function",
    "href": "posts/Rcpp study/Rcpp study.html#executing-the-function",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "We can use our Rcpp functions as usual R functions\n\nrcpp_sum(1:10)\n#&gt; [1] 55"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#embedding-rcpp-code-in-our-r-code",
    "href": "posts/Rcpp study/Rcpp study.html#embedding-rcpp-code-in-our-r-code",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "We can write Rcpp code in our R code in 3 ways.\n\n\nSave Rcpp code as string object in R and compile it with sourceCpp()\n\nsrc &lt;-\n\"#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector v){\n  double sum = 0;\n  for(int i=0; i&lt;v.length(); ++i){\n    sum += v[i];\n  }\n  return(sum);\n}\"\n\nsourceCpp(code = src)\nrcpp_sum(1:10)\n#&gt; [1] 55\n\n\n\n\nWe can omit #include &lt;Rcpp.h&gt; and using namespase Rcpp when we use cppFunction().\n\nsrc &lt;-\"double rcpp_sum(NumericVector v){\n    double sum = 0;\n    for(int i=0; i&lt;v.length(); ++i){\n      sum += v[i];\n    }\n    return(sum);\n  }\n  \"\nRcpp::cppFunction(src)\nrcpp_sum(1:10)\n#&gt; [1] 55\n\n\n\n\nYou can evaluate a single C++ statement by using evalCpp().\n\n# Showing maximum value of double.\nevalCpp('std::numeric_limits&lt;double&gt;::max()')\n#&gt; [1] 1.797693e+308"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#c-11",
    "href": "posts/Rcpp study/Rcpp study.html#c-11",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "C++ 11 is a standard of C++ newly established in 2011. Many new features have been added to make C++ even easier for beginners.\n\n\n\n\n\n\nImportant\n\n\n\nThe code examples in this document are written with C++11 enabled.\n\n\n\n\nTo enable C++11, add the following decription in our Rcpp code. &gt; // [[Rcpp::plugins(\"cpp11\")]]\n\n\n\n\n\n\n// Initialize Vector\n// The next three are the same as c (1, 2, 3).\nNumericVector v1 = NumericVector::create(1.0, 2.0, 3.0);\nNumericVector v2 = {1.0, 2.0, 3.0};\nNumericVector v3   {1.0, 2.0, 3.0}; // You can omit \"=\".\n\n\n\n\nBy using decltype, you can declare a variable of the same type as an existing variable.\n\nint i;\ndecltype(i) x; // variable \"x\" will be int\n\n\n\n\nWe can write a for statement with the same style as R.\n\nIntegerVector v {1,2,3};\nint sum=0;\nfor(auto& x : v) {\n  sum += x;\n}\n\n\nauto& x: The auto& keyword means that each element in the vector v will be referenced as x. Using & allows direct access to each element (by reference), but here it’s primarily for efficiency, so no copy of each element is made.\n\n\n\n\nIt is a function object created as an unnamed function and passed to the other function.\nLambda expressions are written in the form [](){}\n[] specifies how the lambda should access variables from the surrounding scope. Here are the different options:\n\n[] : Capture nothing. The lambda function cannot access any local variables from the surrounding scope.\n[=] : Capture all local variables by value. This means a copy of each variable is made, and the lambda works with the copy.\n[&] : Capture all local variables by reference. The lambda can modify the original variables because it’s accessing them directly.\n[=x, &y]: Capture specific variables in different ways. In this example, the variable x will be captured by value (copied), and y will be captured by reference (accessed directly).\n\nThe return type of this function object is automatically set to the type of the returned value described in {}. If you want to define return type explicitly, write it like []()-&gt;int{}.\nExamples\nR example\n\nv &lt;- c(1,2,3,4,5)\nA &lt;- 2.0\nsapply(v, function(x){A*x})\n#&gt; [1]  2  4  6  8 10\n\nRcpp example We save it as lambda.cpp\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::plugins(\"cpp11\")]]\n// [[Rcpp::export]]\nNumericVector rcpp_lambda_1(){\n  NumericVector v = {1,2,3,4,5};\n  double A = 2.0;\n  NumericVector res =\n    sapply(v, [&](double x){return A*x;});\n  return res;\n}\n\n\nsourceCpp('lambda.cpp')\nrcpp_lambda_1()\n#&gt; [1]  2  4  6  8 10"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#printing-messages",
    "href": "posts/Rcpp study/Rcpp study.html#printing-messages",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "// [[Rcpp::export]]\nvoid rcpp_rcout(NumericVector v){\n  // printing value of vector\n  Rcout &lt;&lt; \"The value of v : \" &lt;&lt; v &lt;&lt; \"\\n\";\n\n  // printing error message\n  Rcerr &lt;&lt; \"Error message\\n\";\n}\n\n\nThis line declares a function named rcpp_rcout that takes a NumericVector as an argument and returns nothing (void).\nRcout is an Rcpp-specific object similar to the standard C++ std::cout, but it is used for printing messages to the R console. It uses &lt;&lt; to concatenate output.\nRcerr is similar to the standard C++ std:cerr, which is used for error messages and diagnostic output. Rcerr is used to send error or warning messages in R, so output sent through Rcerr might be displayed differently (in red text, depending on the R environment) to indicate an issue or warning.\n\n\n\n\nThese functions are used to print formatted output to the R console. It allows you to format the output using placeholders (e.g., %d for integers, %f for floats).\nSyntax:\n\nRprintf( format, variables)\n\nThe first argument is a format string, and subsequent arguments are the values to be inserted into the formatted string. Some format specifier is presented below:\n\n\n\n\n\n\n\nspecifier\nexplanation\n\n\n\n\n%i\nprinting signed integer (int)\n\n\n%u\nprinting unsigned integer (unsigned int)\n\n\n%f\nprinting floating point number (double)\n\n\n%e\nprinting floating point number (double) in exponential style\n\n\n%s\nprinting C string (char*)\n\n\n\n\nAdditionally, Rprintf() and REprintf() can only print data types that exist in standard C++ language, thus you cannot pass data types defined by Rcpp package (such as NumericVector) to Rprintf() directly. If you want to print the values of elements of an Rcpp vector using Rprintf(), you have to pass each element separately to it (see below).\n\n\n// [[Rcpp::export]]\nvoid rcpp_rprintf(NumericVector v){\n    // printing values of all the elements of Rcpp vector  \n    for(int i=0; i&lt;v.length(); ++i){\n        Rprintf(\"the value of v[%i] : %f \\n\", i, v[i]);\n    }\n}"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#data-types",
    "href": "posts/Rcpp study/Rcpp study.html#data-types",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "All the basic data types and data structures provided by R are available in Rcpp. By using these data types, you can directly access the objects that exist in R. ### Vector and Matrix Following seven data types are often used in R.\nlogical integer numeric complex character Date POSIXct ### Vector and matrix There are vector type and matrix types in Rcpp corresponding to those of R.\nThe table below presents the correspondence of data types between R/Rcpp/C++.\n\n\n\n\n\n\n\n\n\n\n\nValue\nR vector\nRcpp vector\nRcpp matrix\nRcpp scalar\nC++ scalar\n\n\n\n\nLogical\nlogical\nLogicalVector\nLogicalMatrix\n-\nbool\n\n\nInteger\ninteger\nIntegerVector\nIntegerMatrix\n-\nint\n\n\nReal\nnumeric\nNumericVector\nNumericMatrix\n-\ndouble\n\n\nComplex\ncomplex\nComplexVector\nComplexMatrix\nRcomplex\ncomplex\n\n\nString\ncharacter\nCharacterVector (StringVector)\nCharacterMatrix (StringMatrix)\nString\nstring\n\n\nDate\nDate\nDateVector\n-\nDate\n-\n\n\nDatetime\nPOSIXct\nDatetimeVector\n-\nDatetime\ntime_t\n\n\n\n\n\nOther than Vector and Matrix, There are several data structures in R such as data.frame, list, S3 class and S4 class. You can handle all of these data structures in Rcpp.\n\n\n\nR\nRcpp\n\n\n\n\ndata.frame\nDataFrame\n\n\nlist\nList\n\n\nS3 class\nList\n\n\nS4 class\nS4\n\n\n\nIn Rcpp, Vector, DataFrame, List are all implemented as kinds of vectors. Namely, Vector is a vector that its elements are scalar values, DataFrame is a vector that its elements are Vectors, List is a vector that its elements are any kind of data types. Thus, Vector, DataFrame, List has many common member functions in Rcpp."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#vector",
    "href": "posts/Rcpp study/Rcpp study.html#vector",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "We can create vector objects in several ways.\n\n// Create a Vector object equivalent to\n// v &lt;- rep(0, 3)\nNumericVector v (3);\n\n// v &lt;- rep(1, 3)\nNumericVector v (3,1);\n\n// v &lt;- c(1,2,3) \n// C++11 Initializer list\nNumericVector v = {1,2,3}; \n\n// v &lt;- c(1,2,3)\nNumericVector v = NumericVector::create(1,2,3);\n\n// v &lt;- c(x=1, y=2, z=3)\nNumericVector v =\n  NumericVector::create(Named(\"x\",1), Named(\"y\")=2 , _[\"z\"]=3);\n\n\n\n\nThis Rcpp function demonstrates various ways of accessing and modifying elements of a NumericVector in R using different types of indices (numerical, integer, character, and logical).\n\n// [[Rcpp::export]]\nvoid rcpp_vector_access() {\n  // Creating vector\n  NumericVector v  {10, 20, 30, 40, 50};\n\n\nA NumericVector v is created with five numeric elements: {10, 20, 30, 40, 50}.\n\n\n\n  // Setting element names\n  v.names() = CharacterVector({\"A\", \"B\", \"C\", \"D\", \"E\"});\n\n\nThis sets the names for the elements in the NumericVector v. After this, the vector looks like:\n\n\nA  B  C  D  E \n10 20 30 40 50\n\n\n  // Preparing vector for access\n  NumericVector numeric = {1, 3};\n  IntegerVector integer = {1, 3};\n  CharacterVector character = {\"B\", \"D\"};\n  LogicalVector logical = {false, true, false, true, false};\n\n\nThese vectors (numeric, integer, character, and logical) are created for indexing:\n\n\n\n  // Getting values of vector elements\n  double x1 = v[0];             // Accesses the first element (10)\n  double x2 = v[\"A\"];           // Accesses the element with name \"A\" (also 10)\n  NumericVector res1 = v[numeric];    // Gets elements at indices 2 and 4 (20, 40)\n  NumericVector res2 = v[integer];    // Same as res1 (20, 40)\n  NumericVector res3 = v[character];  // Gets elements named \"B\" and \"D\" (20, 40)\n  NumericVector res4 = v[logical];    // Gets elements at positions 2 and 4 (20, 40)\n\n\n\nv[0]: Accesses the first element using numeric indexing (zero-based indexing in C++).\nv[“A”]: Accesses the element with the name “A”, which corresponds to the first element (10).\nv[numeric], v[integer], v[character], v[logical]: Accesses multiple elements at once using vectors of different types (numeric, integer, character, logical). All of these access the same elements, 20 and 40, but using different methods of indexing.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nwhen accessing elements from a container like NumericVector in Rcpp, you typically need to declare the type of the variable that will hold the result first.\n\n\n\n\n  // Assigning values to vector elements\n  v[0]   = 100;                 // Replaces the first element with 100\n  v[\"A\"] = 100;                 // Replaces the element named \"A\" with 100\n  NumericVector v2 {100, 200};   // A new vector {100, 200}\n  v[numeric]   = v2;            // Replaces elements at indices 2 and 4 with 100, 200\n  v[integer]   = v2;            // Same as above (2nd and 4th elements)\n  v[character] = v2;            // Replaces elements named \"B\" and \"D\" with 100, 200\n  v[logical]   = v2;            // Replaces elements at logical `true` positions (2nd and 4th) with 100, 200\n}\n\n\n\nv[0] = 100: Changes the first element to 100.\nv[\"A\"] = 100: Changes the element named “A” (which is the same as the first element) to 100.\nv[numeric] = v2, v[integer] = v2, v[character] = v2, v[logical] = v2: These lines replace the selected elements (based on various indexing methods) with the values from the new vector v2 ({100, 200}).\n\n\n\n\n\n\n\n\nImportant\n\n\n\nwhen modifying elements of a vector or container in Rcpp, you must ensure that the new elements are of the same type as the original container.\n\n\n\n\n\nMethods are functions that are attached to an individual object. You can call methods function f() of object v in the form v.f().\n\nNumericVector v = {1,2,3,4,5};\n\n// Calling member function\nint n = v.length(); // 5\n\nThe vector object in Rcpp has methods functiongs listed below\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nsize()\nReturns the number of elements of this vector object.\n\n\nnames()\nReturns the element names of this vector object as CharacterVector.\n\n\noffset(name), findName(name)\nReturns the numerical index of the element specified by the character string name.\n\n\noffset(i)\nReturns the numerical index of the element specified by the numerical index i after bounds check.\n\n\nfill(x)\nFills all the elements of this vector object with scalar value x.\n\n\nsort()\nReturns a vector that sorts this vector object in ascending order.\n\n\nassign(first_it, last_it)\nAssigns values specified by the iterator first_it and last_it to this vector object.\n\n\npush_back(x)\nAppends a scalar value x to the end of this vector object.\n\n\npush_back(x, name)\nAppends a scalar value x to the end of this vector object and sets the name of the element as name.\n\n\npush_front(x)\nAppends a scalar value x to the front of this vector object.\n\n\npush_front(x, name)\nAppends a scalar value x to the front of this vector object and sets the name of the element as name.\n\n\nbegin()\nReturns an iterator pointing to the first element of this vector object.\n\n\nend()\nReturns an iterator pointing to the end (one past the last element) of this vector object.\n\n\ncbegin()\nReturns a const iterator pointing to the first element of this vector.\n\n\ncend()\nReturns a const iterator pointing to the end (one past the last element) of this vector.\n\n\ninsert(i, x)\nInserts a scalar value x at the position specified by the numerical index i.\n\n\ninsert(it, x)\nInserts a scalar value x at the position pointed to by the iterator it.\n\n\nerase(i)\nErases the element at the position specified by the numerical index i.\n\n\nerase(it)\nErases the element at the position pointed to by the iterator it.\n\n\nerase(first_i, last_i)\nErases elements from the position specified by numerical index first_i to last_i.\n\n\nerase(first_it, last_it)\nErases elements from the position specified by the iterators first_it to last_it.\n\n\ncontainsElementNamed(name)\nReturns true if this vector contains an element with the name specified by the character string name.\n\n\n\n\n\n\nA static methods is a function that belongs to a class rather than an instance of the class. This means that you don’t need to create an object (or instance) of the class to call the function; you can call it directly using the class name.\n\nStatic member functions are called using the class name followed by the ::\nExample in Rcpp: NumericVector::create(). Here, create() is a static member function of the class NumericVector, which means you can call it directly using the class name (NumericVector), without creating a NumericVector object first."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#matrix",
    "href": "posts/Rcpp study/Rcpp study.html#matrix",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "Matrix objects can be created in several ways.\n\n// Create a Matrix object equivalent to\n// m &lt;- matrix(0, nrow=2, ncol=2)\nNumericMatrix m1( 2 );\n\n// m &lt;- matrix(0, nrow=2, ncol=3)\nNumericMatrix m2( 2 , 3 );\n\n// m &lt;- matrix(v, nrow=2, ncol=3)\nNumericMatrix m3( 2 , 3 , v.begin() );\n\nIn addition, a matrix object in R is actually a vector that the number of rows and columns are set in the attribute dim.\nThus, if you create a vector with attribute dim in Rcpp and return it to R, it will be treated as a matrix.\n\nmat &lt;- '#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::export]]\nNumericVector rcpp_matrix(){\n    // Creating a vector object\n    NumericVector v = {1,2,3,4};\n\n    // Set the number of rows and columns to attribute dim of the vector object.\n    v.attr(\"dim\") = Dimension(2, 2);\n\n    // Return the vector to R\n    return v;\n}'\nsourceCpp(code=mat)\nrcpp_matrix()\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    3\n#&gt; [2,]    2    4\n\n\nEven if you set a value to attribute dim of a Vector object, the type of the object remains a Vector type in Rcpp code. Thus, if you want to convert it to Matrix type in Rcpp, you need to use as&lt;T&gt;() function.\n\n\n// Set number of rows and columns to attribute dim\nv.attr(\"dim\") = Dimension(2, 2);\n\n// Converting to Rcpp Matrix type\nNumericMatrix m = as&lt;NumericMatrix&gt;(v);\n\n\n\nBy using the () operator, you can get from and assign to the values of elements of a Matrix object by specifying its column number and row number.\n\n// Creating a 5x5 numerical matrix\nNumericMatrix m( 5, 5 );\n\n// Retrieving the element of row 0 and column 2\ndouble x = m( 0 , 2 );\n\n\n\nThis line retrieves the element at row 0, column 2 of the matrix m and stores it in the variable x.\nThe parentheses m(0, 2) are used for element access in the matrix, similar to m[0, 2] in R.\n\n\n\nNumericVector v = m( 0 , _ );\n\n\n\nThis line copies all the values in row 0 (i.e., the entire first row) of the matrix m into the vector v.\nThe underscore _ is a placeholder that represents “all elements” in the corresponding dimension.\n\n\n\nNumericVector v = m( _ , 2 );\n\n\n\nThis line copies all the values in column 2 (i.e., the third column) of the matrix m into the vector v.\n\n\n\nNumericMatrix m2 = m( Range(0,1), Range(2,3) );\n\n\n\nThis line copies a submatrix of m consisting of the values in rows 0 and 1 (first and second rows) and columns 2 and 3 (third and fourth columns) into a new matrix m2. Range(0,1) specifies that rows 0 and 1 should be selected, and Range(2,3) specifies that columns 2 and 3 should be selected.\n\n\n\nm[5]; // This points to the same element as m(0,1)\n\n\nThis line demonstrates linear indexing into the matrix. While NumericMatrix is a two-dimensional structure, it can also be treated like a 1D array when accessed with square brackets [].\n\n\n\n\nRcpp also provides types that hold “references” to specific parts of a matrix.\n\nReferencing a Column:\n\n\nNumericMatrix::Column col = m( _ , 1 );\n\n\n\nm(_, 1): This accesses column 1 of the matrix m (zero-based indexing, so it refers to the second column).\nNumericMatrix::Column: This type is a reference to a specific column of the matrix. It doesn’t create a copy of the column but rather provides direct access to the elements in column 1.\n\n\n\nReferencing a Row:\n\n\nNumericMatrix::Row row = m( 1 , _ );\n\n\n\nm(1,_): Thisaccesses row 1 of the matrix m\nNumericMatrix::Row: This type is a reference to a specific row of the matrix.\n\n\n\nReferencing a Submatrix\n\n\nNumericMatrix::Sub sub = m( Range(0,1) , Range(2,3) );\n\n\n\nRange(0,1): This specifies the range of rows to select (rows 0 and 1, the first two rows).\nRange(2,3): This specifies the range of columns to select (columns 2 and 3, the third and fourth columns).\nNumericMatrix::Sub: This type is a reference to a submatrix of m. It references the elements in the submatrix defined by the row and column ranges.\n\n\n\n\n\nSince Matrix is actually Vector, Matrix basically has the same member functions as Vector. Thus, member functions unique to Matrix are only presented below.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nnrow() or rows()\nReturns the number of rows.\n\n\nncol() or cols()\nReturns the number of columns.\n\n\nrow(i)\nReturns a reference Vector::Row to the i-th row.\n\n\ncolumn(i)\nReturns a reference Vector::Column to the i-th column.\n\n\nfill_diag(x)\nFills the diagonal elements with the scalar value x.\n\n\noffset(i, j)\nReturns the numerical index in the original vector of the matrix corresponding to the element at row i and column j.\n\n\n\n\n\n\nMatrix basically has the same static member function as Vector. The static member functions unique to Matrix are shown below. Matrix::diag( size, x ): Returns a diagonal matrix whose number of rows and columns equals to “size” and the value of the diagonal element is “x”.\n\ncppFunction(\"\nNumericMatrix create_diag_matrix(int size, double x) {\n    // Create a diagonal matrix of the given size with x on the diagonal\n    NumericMatrix mat = NumericMatrix::diag(size, x);\n    return mat;\n}\")\ncreate_diag_matrix(5,2)\n\n\n\n\n\n\n\nImportant\n\n\n\nx is a scalar value that will be placed along the diagonal of the matrix.\n\n\n\n\n\n\nrownames\n\n\nget the row name of matrix m:\n\n\nCharacterVector ch = rownames(m);\n\n\nset the row name of matrix m:\n\n\nrownames(m) = ch\n\n\ncolnames\n\n\nget the column name of matrix m:\n\n\nCharacterVector ch = colnames(m);\n\n\nset the column name of matrix m:\n\n\ncolnames(m) = ch\n\n\ntranspose return the transposed matrix of matirx m:\n\n\ntranspose(m)"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#vector-operations",
    "href": "posts/Rcpp study/Rcpp study.html#vector-operations",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "By using the + - * / operator you can perform elementwise arithmetic operations between vectors of the same length.\n\nNumericVector x ;\nNumericVector y ;\n\nVector and vector operation\n\n// Vector and vector operation\nNumericVector res = x + y ;\nNumericVector res = x - y ;\nNumericVector res = x * y ;\nNumericVector res = x / y ;\n\nVector and scalar operation\n\n// Vector and scalar operation\nNumericVector res = x   + 2.0 ;\nNumericVector res = 2.0 - x;\nNumericVector res = y   * 2.0 ;\nNumericVector res = 2.0 / y;\n\nExpression and expression operation\n\nNumericVector res = x * y + y / 2.0 ;\nNumericVector res = x * ( y - 2.0 ) ;\nNumericVector res = x / ( y * y ) ;\n\nThe - operator inverts the sign.\n\nNumericVector res = -x ;\n\n\n\n\nComparison of vectors using == ! = &lt; &gt; &gt;= &lt;= operators produces logical vectors. You can also access vector elements using logical vectors.\nComparison of vector and vector\n\nLogicalVector res = x &lt; y ;\nLogicalVector res = x &gt; y ;\nLogicalVector res = x &lt;= y ;\nLogicalVector res = x &gt;= y ;\nLogicalVector res = x == y ;\nLogicalVector res = x != y ;\n\nComparison of vector and scalar\n\nLogicalVector res = x &lt; 2 ;\nLogicalVector res = 2 &gt; x;\nLogicalVector res = y &lt;= 2 ;\nLogicalVector res = 2 != y;\n\nComparison of expression and expression\n\nLogicalVector res = ( x + y ) &lt; ( x*x ) ;\nLogicalVector res = ( x + y ) &gt;= ( x*x ) ;\nLogicalVector res = ( x + y ) == ( x*x ) ;\n\n!(...): The logical NOT operator ! negates the result of the comparison. In other words, it turns TRUE into FALSE and FALSE into TRUE.\n\nLogicalVector res = !(x &lt; y);\n\nAccessing the elements of the vector using logical vectors.\n\nNumericVector res = x[x &lt; 2];"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#logical-operations",
    "href": "posts/Rcpp study/Rcpp study.html#logical-operations",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "Although in C++ the boolean type (bool) has only two possible values, true (1) and false (0), R’s logical vectors have a third possible value: NA (missing or undefined). Because C++ bool can’t represent this third state, Rcpp uses integers to represent the elements of R’s LogicalVector.\nIn Rcpp, elements of a LogicalVector are stored as integers to accommodate the extra NA value. Specifically, these values are represented as: + TRUE: 1 (same as C++ true) + FALSE: 0 (same as C++ false) + NA: NA_LOGICAL, which is a special constant defined as the minimum value of an integer: -2147483648 (the smallest value for a 32-bit signed integer).\n\n\n\nUse the operator & (logical product) | (logical sum) ! (Logical negation) for the logical operation for each element of LogicalVector.\n\nLogicalVector v1 = {1,1,0,0};\nLogicalVector v2 = {1,0,1,0};\n\nLogicalVector res1 = v1 & v2;\nLogicalVector res2 = v1 | v2;\nLogicalVector res3 = !(v1 | v2);\n\nRcout &lt;&lt; res1 &lt;&lt; \"\\n\"; // 1 0 0 0\nRcout &lt;&lt; res2 &lt;&lt; \"\\n\"; // 1 1 1 0\nRcout &lt;&lt; res3 &lt;&lt; \"\\n\"; // 0 0 0 1\n\n\n\n\n\n\nExamples of functions that receive LogicalVector are all(), any() and ifelse().\n\nall(v) returns TRUE when all elements of v are TRUE, and any(v) returns TRUE if any of v’s elements are TRUE.\n\nIn Rcpp, the return type of both all() and any() is not a simple bool, but a more complex type called SingleLogicalResult.\nThis type can represent not only TRUE or FALSE, but also NA (the third possible logical value in R). As a result, the return value of all() or any() cannot be directly used in a conditional statement like an if statement in C++.\nTo convert the SingleLogicalResult from all() or any() into a bool, Rcpp provides helper functions: + is_true(): Returns true if the result is TRUE. + is_false(): Returns true if the result is FALSE. + is_na(): Returns true if the result is NA.\n\n\n\nifelse (v, x1, x2) receives the logical vector v, and returns the corresponding element of x1 when the element of v is TRUE and the corresponding element of x2 when it is FALSE.\n\nx1 and x2 must either be scalars or vectors. If they are vectors, their length must match the length of v. This ensures that there is a corresponding element in x1 or x2 for each element in v.\n\n\nNumericVector v1;\nNumericVector v2;\n//Number of elements of vector\nint n = v1.length();\n\nIn case, both x1 and x2 are scalar\n\nIntegerVector res1     = ifelse( v1&gt;v2, 1, 0);\nNumericVector res2     = ifelse( v1&gt;v2, 1.0, 0.0);\n\n\n\n\n\n\n\nImportant\n\n\n\nSince ifelse() does not work with a scalar character string, we need to use a string vector whose values of elements are all the same.\n\n\n\nCharacterVector chr_v1 = rep(CharacterVector(\"T\"), n);\nCharacterVector chr_v2 = rep(CharacterVector(\"F\"), n);\nCharacterVector res3   = ifelse( v1&gt;v2, chr_v1, chr_v2);\n\nIn case, x1 and x2 are vector and scalar\n\nIntegerVector res4 = ifelse(v1 &gt; v2, int_v1, 0);\nNumericVector res5 = ifelse(v1 &gt; v2, num_v1, 0.0);\nCharacterVector res6 = ifelse(v1 &gt; v2, chr_v1, Rf_mkChar(\"F\")); // Note\n\n\n\nFor integer and numeric vectors, the scalar values (0 and 0.0) are recycled as needed\nFor character vectors, you cannot directly use a scalar string like \"F\"; instead, you use Rf_mkChar(\"F\"), which creates an internal SEXP (R object) representing the string “F”."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#data-frame",
    "href": "posts/Rcpp study/Rcpp study.html#data-frame",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "In Rcpp, DataFrame is implemented as a kind of vector. In other words, Vector is a vector whose element is scalar value, while DataFrame is a vector whose elements are Vectors of the same length.\nDataFrame::create() is used to create a DataFrame object.\n\n// Creating DataFrame df from Vector v1, v2\nDataFrame df = DataFrame::create(v1, v2);\n\nAlso, use Named() or _[] if you want to specify column names when creating DataFrame　object.\n\n// When giving names to columns\nDataFrame df = DataFrame::create( Named(\"V1\") = v1 , _[\"V2\"] = v2 );\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen you create a DataFrame with DataFrame::create(), the value of the originalVector element will not be duplicated in the columns of the DataFrame, but the columns will be the “reference” to the original Vector. Therefore, changing the value of the original Vector changes the value of the columns. To avoid this, use clone().\n\n\n\ndf &lt;- '#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::export]]\nDataFrame rcpp_df(){\n  // Creating vector v\n  NumericVector v = {1,2};\n  // Creating DataFrame df\n  DataFrame df = DataFrame::create( Named(\"V1\") = v,         // simple assign\n                                    Named(\"V2\") = clone(v)); // using clone()\n  // Changing vector v\n  v = v * 2;\n  return df;\n}'\nsourceCpp(code=df)\nrcpp_df()\n\n\n\n\nWhen you access a specific column of a DataFrame in Rcpp, that column is temporarily assigned to a Vector object. The Vector object allows you to manipulate or access the values of that column as if it were a separate vector.\n\n\n\n\n\n\nWarning\n\n\n\nAs with DataFrame creation, assigning aDataFrame column to Vector in the above way will not copy the column value to Vector object, but it will be a “reference” to the column. Therefore, when you change the values of Vector object, the content of the column will also be changed.\n\n\n\n\nYou can specify which column of the DataFrame you want to access using different types of vectors:\n\nNumeric Vector (Column Number):You can specify a column by its index (0-based). Example: df[0] would return the first column.\nString Vector (Column Name):You can access a column by its name using a string, which is more intuitive and readable when dealing with named columns.\nLogical Vector: Each element of the logical vector corresponds to whether a column should be included (TRUE) or excluded (FALSE). The length of the logical vector must match the number of columns in the data frame.\n\n\n\n\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nnrows()\nReturns the number of rows.\n\n\nncol()\nReturns the number of columns.\n\n\nlength()\nReturns the number of columns.\n\n\nsize()\nReturns the number of columns.\n\n\nnames()\nReturns the column names as a CharacterVector.\n\n\noffset(name) or findName(name)\nReturns the numerical index of the column with the name specified by the string name.\n\n\nfill(v)\nFills all the columns of this DataFrame with the Vector v.\n\n\nassign(first_it, last_it)\nAssigns columns in the range specified by the iterators first_it and last_it to this DataFrame.\n\n\npush_back(v)\nAdds Vector v to the end of the DataFrame.\n\n\npush_back(v, name)\nAppends a Vector v to the end of the DataFrame and specifies the name of the added column with the string name.\n\n\npush_front(x)\nAppends a Vector v at the beginning of this DataFrame.\n\n\npush_front(x, name)\nAppends a Vector v at the beginning of this DataFrame and specifies the name of the added column with the string name.\n\n\nbegin()\nReturns an iterator pointing to the first column of this DataFrame.\n\n\nend()\nReturns an iterator pointing to the end of this DataFrame.\n\n\ninsert(it, v)\nAdds Vector v to this DataFrame at the position pointed by the iterator it and returns an iterator to that element.\n\n\nerase(i)\nDeletes the i-th column of this DataFrame and returns an iterator to the column just after the erased column.\n\n\nerase(it)\nDeletes the column specified by the iterator it and returns an iterator to the column just after the erased column.\n\n\nerase(first_i, last_i)\nDeletes columns from first_i to last_i - 1 and returns an iterator to the column just after the erased columns.\n\n\nerase(first_it, last_it)\nDeletes the range of columns specified by the iterators first_it to last_it - 1 and returns an iterator to the column just after the erased columns.\n\n\ncontainsElementNamed(name)\nReturns true if this DataFrame has a column with the name specified by the string name.\n\n\ninherits(str)\nReturns true if the attribute “class” of this object contains the string str."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#list",
    "href": "posts/Rcpp study/Rcpp study.html#list",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "In Rcpp, List is implemented as a kind of vector. In other words, Vector is a vector whose element is scalar value, while List is a vector whose elements are any kinds of data types.\n\n\nTo create a List object we use the List::create() function. Also, to specify the element name when creating List, use Named() function or _[].\n\n// Create list L from vector v1, v2\nList L = List::create(v1, v2);\n\n// When giving names to elements\nList L = List::create(Named(\"name1\") = v1 , _[\"name2\"] = v2);\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen you create a List with DataFrame::create(), the value of the originalVector element will not be duplicated but the elements will be the “reference” to the original Vector. Therefore, changing the value of the original Vector changes the value of the list. To avoid this, use clone().\n\n\n\n\n\nWhen accessing a specific element of List, we assign it to the other object and access it via that object.\nThe elements of List can be specified by numerical index, element names and logical vector.\n\n\n\nList has the same member functions as Vector"
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#s3s4-class",
    "href": "posts/Rcpp study/Rcpp study.html#s3s4-class",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "The S3 class is actually a list whose attribute class has its own value.\nWe use an example to demonstrate how to use it in Rcpp\n\ndouble rcpp_rmse(List lm_model) {\n    // Since S3 is a list, data type of the argument is specified as List.\n\n\nS3 objects in R, such as objects created by lm(), are typically lists with an additional class attribute. Since an S3 object is fundamentally a list, in Rcpp, we can use the List data type to receive it.\n\n\nif (! lm_model.inherits(\"lm\")) stop(\"Input must be a lm() model object.\");\n\n\nThe inherits(\"lm\") function checks whether the input object (the list) belongs to the lm class. This ensures that the input object is an lm object.\n\n\n    // Extracting residuals (i.e. actual - prediction) from the S3 object\n    NumericVector resid  = lm_model[\"residuals\"];\n\n\n\nIn an lm object, residuals are stored in the “residuals” component.\nSince the S3 object is a list, we can access the “residuals” component using list-like indexing (lm_model[“residuals”]), which extracts the residuals as a NumericVector in Rcpp.\n\n\n\n    // Number of elements of the residual vector\n    R_xlen_t n = resid.length();\n\n\n\nThe length() function is used to get the number of elements in the resid vector (i.e., the number of residuals).\nR_xlen_t is a type that represents the length of vectors in R. It is typically used in Rcpp when dealing with vector lengths.\n\n\n\nR_xlen_t is large enough to handle very long vectors, which is crucial when you’re working with vectors whose length might exceed the range of a standard integer (which is 2^31 - 1 in R, roughly 2 billion).\n\n\n    // The sum of squares of the residual vector\n    double rmse(0.0);\n    for(double& r : resid){\n        rmse += r*r;\n    }\n\n    // Divide the residual sum of squares by the number of elements and take the square root\n    return(sqrt((1.0/n)*rmse));\n}\n\n\n\nwait to update."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#string",
    "href": "posts/Rcpp study/Rcpp study.html#string",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "String is a scalar type corresponding to the element of CharacterVector. String can also handle NA values (NA_STRING) which are not supported by the C character string char* and the C++ string std::string.\n\n\nThere are three main ways to create a String object. Each approach reflects different sources for creating the String object:\n\nCreating a String from a C/C++ String (Character Pointer or std::string):\n\n\n// Create String from C-style string\nString s1 = \"Hello, world!\";\n\n// Create String from std::string\nstd::string cpp_str = \"C++ string\";\nString s2 = cpp_str;\n\n\n\ns1 is created from a C-style string (\"Hello, world!\").\ns2 is created from a C++ string (std::string).\n\n\n\nCreating a String from Another String Object:\n\n\nYou can create a new String object by copying an existing String object in Rcpp.\n\n\nString s1 = \"Original string\";\n\n// Create a new String from another String object\nString s2 = s1;\n\n\nCreating a String from an Element of a CharacterVector:\n\n\nCharacterVector cv = CharacterVector::create(\"one\", \"two\", \"three\");\n\n// Create a String from the second element of the CharacterVector\nString s = cv[1];  // Note: 0-based indexing, so this accesses \"two\"\n\n\n\n\nIn Rcpp, the String class supports the += operator, which allows you to append another string (or string-like object) to an existing String object.\n\n// Creating String object\nString s(\"A\");\n\n// Conbining a string\ns += \"B\";\n\nRcout &lt;&lt; s &lt;&lt; \"\\n\"; \n// \"AB\"\n\n\n\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nreplace_first(str, new_str)\nReplace the first substring that matches the string str with the string new_str.\n\n\nreplace_last(str, new_str)\nReplace the last substring that matches the string str with the string new_str.\n\n\nreplace_all(str, new_str)\nReplace all substrings that match the string str with the string new_str.\n\n\npush_back(str)\nCombine the string str to the end of this String object. (Same as += operator)\n\n\npush_front(str)\nCombine the string str at the beginning of this String object.\n\n\nset_na()\nSet NA value to this String object.\n\n\nget_cstring()\nConvert the string of this String object into a C character string constant (const char*) and return it.\n\n\nget_encoding()\nReturns the character encoding. The encoding is represented by cettype_t.\n\n\nset_encoding(enc)\nSet the character encoding specified by cettype_t."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#date-and-datevector",
    "href": "posts/Rcpp study/Rcpp study.html#date-and-datevector",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "The following codes illustrates different ways to create a Date object in Rcpp, representing a specific date.\n\nDate d;  // \"1970-01-01\"\n\n\n\nDate d; creates a Date object d that represents the epoch date “1970-01-01”, which is considered the default starting point for dates in many computing systems, including R.\n\n\n\nDate d(1);  // \"1970-01-01\" + 1 day\n\n\n\nDate d(1); creates a Date object d that represents one day after the epoch date.\n\n\n\nDate d(1.1);  // \"1970-01-01\" + ceil(1.1) day\n\n\n\nDate d(1.1); creates a Date object d that represents 1.1 days after “1970-01-01”. The number is rounded up (using ceil()), so it is treated as 2 days after “1970-01-01”.\n\n\n\nDate d(\"2000-01-01\", \"%Y-%m-%d\");  // Date specified by a string with a format\n\n\nThis creates a Date object d from a string \"2000-01-01\" with the format \"%Y-%m-%d\"\n\nDate from Day, Month, and Year (mm/dd/yyyy):\n\nDate d(1, 2, 2000);  // 2000-01-02 (mon, day, year)\n\n\n\n\nDate has operators +, -, &lt;, &gt;, &gt;=, &lt;=, ==, !=.\nBy using these operators, you can perform addition of days (+), difference calculation of date (-), and comparison of dates (&lt;, &lt;=, &gt;, &gt;=, ==, !=) . ### Member functions\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nformat()\nReturns the date as a std::string using the same specification as base R. The default format is YYYY-MM-DD.\n\n\ngetDay()\nReturns the day of the date.\n\n\ngetMonth()\nReturns the month of the date.\n\n\ngetYear()\nReturns the year of the date.\n\n\ngetWeekday()\nReturns the day of the week as an int. (1:Sun, 2:Mon, 3:Tue, 4:Wed, 5:Thu, 6:Sat).\n\n\ngetYearday()\nReturns the number of the date through the year (with January 1st as 1 and December 31st as 365).\n\n\nis_na()\nReturns true if this object is NA.\n\n\n\n\n\n\nIn Rcpp, both DateVector and DateTimeVector are internally stored as numeric types (specifically, doubles). This design simplifies certain internal calculations but can be confusing when working with individual elements of these vectors.\nThis behavior is important because when you subset a DateVector using the [] operator, you extract a double, which represents the date as the number of days since the epoch date (1970-01-01).\nTo work with individual Date or DateTime objects from a DateVector or DateTimeVector, you need to explicitly cast or convert the extracted element back into a Date or DateTime object.\nExample:\n\n// [[Rcpp::export]]\nvoid print_year_of_date(DateVector dates) {\n    for (int i = 0; i &lt; dates.size(); ++i) {\n        // Convert the extracted double to a Date object\n        Date single_date = dates[i];  // Convert double to Date\n        int year = single_date.getYear();  // Now you can call getYear()\n        Rcpp::Rcout &lt;&lt; \"Year: \" &lt;&lt; year &lt;&lt; std::endl;\n    }\n}\n\n\n\ndates[i] returns a double by default.\nDate single_date = dates[i];: We explicitly convert the double value to a Date object, allowing us to use the getYear() method."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#robject",
    "href": "posts/Rcpp study/Rcpp study.html#robject",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "The RObject type in Rcpp is a flexible and general-purpose type that can represent any kind of R object.\nHere is an example that demonstrates how RObject can be used in Rcpp to accept and handle different types of R objects.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nvoid handle_any_type(RObject obj) {\n    // Check if the object is a NumericVector\n    if (obj.is&lt;NumericVector&gt;()) {\n        NumericVector num_vec = as&lt;NumericVector&gt;(obj);\n        Rcpp::Rcout &lt;&lt; \"Numeric Vector: \" &lt;&lt; num_vec &lt;&lt; std::endl;\n    } \n    // Check if the object is a CharacterVector\n    else if (obj.is&lt;CharacterVector&gt;()) {\n        CharacterVector char_vec = as&lt;CharacterVector&gt;(obj);\n        Rcpp::Rcout &lt;&lt; \"Character Vector: \" &lt;&lt; char_vec &lt;&lt; std::endl;\n    } \n    // Check if the object is a List\n    else if (obj.is&lt;List&gt;()) {\n        List lst = as&lt;List&gt;(obj);\n        Rcpp::Rcout &lt;&lt; \"List: \" &lt;&lt; lst &lt;&lt; std::endl;\n    } \n    // Handle unknown types\n    else {\n        Rcpp::Rcout &lt;&lt; \"Unknown type!\" &lt;&lt; std::endl;\n    }\n}\n\n\n\n\nas&lt;&gt;() is a template function in Rcpp that allows you to convert an RObject to a more specific type when you know the type of the object or have determined it dynamically.\n\n\nNumericVector num_vec = as&lt;NumericVector&gt;(obj);  // Convert RObject to NumericVector\n\n\nThis converts the RObject into a NumericVector when you are sure that it contains a numeric vector."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#cautions-in-handling-rcpp-objects",
    "href": "posts/Rcpp study/Rcpp study.html#cautions-in-handling-rcpp-objects",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "In Rcpp, when you assign an object (like a vector, list, or matrix) v1 to another object v2 using the = operator (e.g., v2 = v1;), no deep copy is made. Instead, v2 becomes an alias to v1, meaning that both v1 and v2 point to the same underlying data in memory.\nIf you want v2 to be a completely independent copy of v1, so that changes to v1 do not affect v2, you need to perform a deep copy. In Rcpp, you can use the clone() function to create a deep copy.\n\n\n\nYou should use R_xlen_t as data type for numerical index or the number of elements to support long vector in your Rcpp code.\n\n\n\nIn Rcpp, when you access an element of a vector with [] or (), you do not directly get the element as its native type (e.g., double, int, or String). Instead, you get a Vector::Proxy object. This Proxy object acts as an intermediary that allows you to modify the vector element directly or retrieve its value, but it is not the same as the element’s actual type.\nTo resolve this, you either: + Assign v[i] to a new object of the expected type. + Convert the Proxy to the native type using as&lt;T&gt;()."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#r-like-functions",
    "href": "posts/Rcpp study/Rcpp study.html#r-like-functions",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "Here is a list of Rcpp functions similar to R functions.\nIf you know for certain that your vector does not contain any NA values, you can optimize your code by using the noNA() function. noNA() marks the vector as guaranteed to be free of NA values, which allows Rcpp to skip NA checks and perform calculations more efficiently.\n\nList is too long to illustrate."
  },
  {
    "objectID": "posts/Rcpp study/Rcpp study.html#probability-distribution",
    "href": "posts/Rcpp study/Rcpp study.html#probability-distribution",
    "title": "Rcpp Study Record",
    "section": "",
    "text": "In Rcpp, probability distribution functions exist in two different namespaces:\n\nRcpp:: namespace:\n\n\nFunctions in this namespace return vectors.\nThese functions are designed to be similar to their counterparts in base R. You can pass a vector of values to these functions and they will return a vector of results.\n\n\nR:: namespace:\n\n\nFunctions in this namespace return scalar values (a single value).\nIf you only need a single value from the distribution function, using the R:: version of the function can be more efficient because it avoids the overhead of vectorization.\n\n\nsort_cpp &lt;- '#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n// [[Rcpp::export]]\nNumericVector sort_numeric_vector(NumericVector x) {\n    std::sort(x.begin(), x.end());\n    return x;\n}'\nsourceCpp(code=sort_cpp)"
  },
  {
    "objectID": "posts/Naive bayes model/Naive bayes model.html",
    "href": "posts/Naive bayes model/Naive bayes model.html",
    "title": "Naive Bayes Model",
    "section": "",
    "text": "We build a Naive Bayes classifier that can handle any classification problem, assuming continuous variables follow a normal distribution. This classifier is not limited to the specific problem in the exercises."
  },
  {
    "objectID": "posts/Naive bayes model/Naive bayes model.html#function-bayesclasifier",
    "href": "posts/Naive bayes model/Naive bayes model.html#function-bayesclasifier",
    "title": "Naive Bayes Model",
    "section": "1 Function Bayesclasifier",
    "text": "1 Function Bayesclasifier\nThe following function fits a Naive Bayes model to the data, estimating prior probabilities and conditional probabilities for both continuous and categorical features. This function takes four inputs: the data, the response (a character string specifying which column contains the class labels), the prior (if provided), and the Laplace smoothing parameter. The output is a list containing the conditional probabilities for each variable, the prior probabilities, an indicator of which columns are numeric or categorical, and the levels of the class labels. The returned list is of class naiveBayes, which allows for method dispatching specific to this model.\n\n\nCode\nBayesclasifier &lt;- function(data, response, prior = NULL, alpha = 0) {\n  # Step 1: Extract the target variable (response)\n  # 'label' contains the target class from the 'response' column of the data\n  label &lt;- data[[response]]\n  label_counts &lt;- table(label)\n  level &lt;- unique(label)# Identify unique classes in the target variable\n  # Remove the response column from the data \n  #(since it should not be used as a predictor)\n  data[[response]] &lt;- NULL\n  # Step 2: Calculate prior probabilities if not provided\n  if (is.null(prior)) {\n    prior &lt;- prop.table(label_counts)\n  }\n  # Step 3: Identify numeric and categorical columns\n  is_num &lt;- sapply(data, function(x) is.numeric(x))\n  # Step 4: Process numeric and categorical columns separately\n  tbl &lt;- lapply(data,function(col){\n    if (is.numeric(col)){\n      # For numeric columns, calculate the mean and variance\n      #for each class in the target variable\n      means &lt;- tapply(col, label, mean,na.rm = TRUE)\n      sd &lt;- tapply(col, label, sd,na.rm = TRUE)\n      cbind(means,sd)\n    }\n    else {\n      # For categorical columns, calculate smoothed counts \n      # and conditional probabilities\n      # Do not display the count of NA values (this is the default behavior)\n      counts &lt;- table(label, col)\n      # Apply Laplace smoothing to avoid zero probabilities\n      smoothed_probs &lt;- sweep(counts + alpha, 1,\n                              label_counts+alpha*ncol(counts), \"/\")\n      # Calculate conditional probabilities\n      return(smoothed_probs)\n    }\n  })\n  # Return the model as a list containing: \n  #1) prior probabilities, 2) tables of statistics, 3) and metadata\n  result &lt;- list(\n    prior = prior, tables = tbl, \n    isnumeric=is_num,\n    level=level)\n  # Assign a class to the result for method dispatch\n  class(result) &lt;- \"naiveBayes_clasifier\"\n  return(result)\n}"
  },
  {
    "objectID": "posts/Naive bayes model/Naive bayes model.html#function-predict.naivebayes_clasifier",
    "href": "posts/Naive bayes model/Naive bayes model.html#function-predict.naivebayes_clasifier",
    "title": "Naive Bayes Model",
    "section": "2 Function predict.naiveBayes_clasifier",
    "text": "2 Function predict.naiveBayes_clasifier\nThe predict function takes a trained Naive Bayes model and new data as inputs, and returns predicted class labels or class probabilities depending on the specified type. For missing values (NA), the function handles them by assigning neutral probabilities (effectively ignoring them in the likelihood calculation).\n\n\nCode\npredict.naiveBayes_clasifier &lt;- function(model, newdata, type = \"class\") {\n  logprior &lt;- log(model$prior)   \n  len &lt;- length(model$prior)\n  # Match newdata columns with model attributes\n  match_idx &lt;- match(names(model$tables), names(newdata))  \n  \n  # Step 3: Preallocate log probability matrix for faster computation\n  Logprob &lt;- matrix(0, nrow = len, ncol = nrow(newdata),dimnames = list(model$level,NULL))\n  # Step 1: Convert categorical variables to factors with matching levels\n  for (v in seq_along(match_idx)) {\n    if (model$isnumeric[v]){\n      nd &lt;- newdata[, match_idx[v]]\n      tbl &lt;- model$tables[[v]]\n      means &lt;- tbl[, 1]\n      sd &lt;- tbl[, 2]\n      notna &lt;- !is.na(nd)\n      Logprob[,notna] &lt;-Logprob[,notna]+ vapply(nd[notna],function(x) dnorm(x,means,sd,log=TRUE),numeric(len))\n    }\n    else {\n      nd &lt;- factor(newdata[,match_idx[v]],\n                             levels = colnames(model$tables[[v]]))\n      notna &lt;- !is.na(nd)\n      Logprob[,notna] &lt;-Logprob[,notna]+ log(model$tables[[v]][,nd[notna]])\n    }\n  }\n  # Step 5: Add log-priors to the computed log-likelihoods\n  Logprob &lt;- sweep(Logprob, 1, logprior, \"+\")\n  # Step 6: Return predictions based on the specified type ('class' or 'raw')\n  if (type == \"class\") {\n    pred_classes &lt;- model$level[apply(Logprob,2,which.max)]\n    return(pred_classes)\n  } else {\n    # If type == \"raw\", return probabilities for all classes\n    probs &lt;- exp(Logprob)  # Convert log-probabilities back to normal scale\n    # Normalize probabilities so they sum to 1\n    probs &lt;- apply(probs,2,function(x)x/sum(x) ) \n    return(t(probs))\n  }\n}"
  },
  {
    "objectID": "posts/Naive bayes model/Naive bayes model.html#function-confusion_matrix-and-roc_auc",
    "href": "posts/Naive bayes model/Naive bayes model.html#function-confusion_matrix-and-roc_auc",
    "title": "Naive Bayes Model",
    "section": "3 Function confusion_matrix and roc_auc",
    "text": "3 Function confusion_matrix and roc_auc\nThe first function computes the confusion matrix, which compares the true class labels with the predicted class labels to evaluate the performance of the classification model.\n\n\nInput:\n\ntrue_labels: A vector of true class labels for the dataset.\npredicted_class: A vector of predicted class labels for the dataset. This is typically the output after selecting the class with the highest predicted probability for each instance.\n\nOutput:\n\nA confusion matrix, where rows represent the actual class labels and columns represent the predicted class labels. \n\n\n\nThe second function computes the ROC curve and Area Under the Curve (AUC) for each class in the classification problem.\n\n\nInput: the same as above\nOutput:\nA list containing:\n\nroc_data: A data frame with columns FPR (False Positive Rate), TPR (True Positive Rate), and class for each class, representing the ROC curve points for each class.\nauc: A named vector where each entry is the AUC value for one class, with the class names as the vector names.\n\n\n\nWhile these functions can handle binary classification, they are especially suited for multi-class classification problems. In multi-class classification, the “one-vs-all” (or “one-vs-rest”) approach is applied. This means that for each class, the function treats it as the positive class and considers all other classes as the negative class.\n\n\nCode\n# Function to create a confusion matrix based on true labels and predicted class labels\nconfusion_matrix &lt;- function(true_labels, predicted_class) {\n  class_names &lt;- unique(c(true_labels, predicted_class))\n  \n  # Create an empty confusion matrix\n  conf_matrix &lt;- matrix(0, nrow = length(class_names), ncol = length(class_names),\n                        dimnames = list(\"Actual\" = class_names, \"Predicted\" = class_names))\n  \n  # Populate the confusion matrix\n  for (i in seq_along(true_labels)) {\n    true_class &lt;- true_labels[i]\n    pred_class &lt;- predicted_class[i]\n    conf_matrix[true_class, pred_class] &lt;- conf_matrix[true_class, pred_class] + 1\n  }\n  \n  return(conf_matrix)\n}\nroc_auc &lt;- function(true_labels, predicted_probs) {\n  # Get unique class names\n  classes &lt;- colnames(predicted_probs)\n  \n  # Internal function to compute sensitivity and specificity with vectorized operations\n  compute_roc_auc &lt;- function(binary_labels, pos_prob) {\n    # Sort the predicted probabilities and corresponding labels once\n    order_index &lt;- order(pos_prob, decreasing = TRUE)\n    sorted_labels &lt;- binary_labels[order_index]\n    \n    # Number of positive and negative samples\n    M &lt;- sum(sorted_labels == 1)\n    N &lt;- sum(sorted_labels == 0)\n    \n    # Cumulative sum to calculate sensitivity (sen) and specificity (spe)\n    sen &lt;- cumsum(sorted_labels == 1)  # True positives as we go down the list\n    spe &lt;- cumsum(sorted_labels == 0)  # False positives as we go down the list\n    \n    # Sensitivity and specificity as ratios\n    TPR &lt;- c(0, sen / M)\n    FPR &lt;- c(0, spe / N)\n    \n    # Calculate AUC using the trapezoidal rule (efficiently using vectorized operations)\n    auc &lt;- sum((FPR[-1] - FPR[-length(FPR)]) * (TPR[-1] + TPR[-length(TPR)])) / 2\n    \n    # Return results as a matrix for better performance\n    return(list(roc = data.frame(FPR = FPR, TPR = TPR), auc = auc))\n  }\n  \n  # Check if it's a binary classification problem\n  if (length(classes) == 2) {\n    class_name &lt;- classes[1]\n    binary_labels &lt;- ifelse(true_labels == class_name, 1, 0)\n    pos_prob &lt;- predicted_probs[, class_name]\n    \n    # Compute ROC for the binary classification\n    roc_auc_result &lt;- compute_roc_auc(binary_labels, pos_prob)\n    roc_data &lt;- roc_auc_result$roc\n    roc_data$class &lt;- class_name  # Add class column\n    auc &lt;- setNames(roc_auc_result$auc, class_name)  # Return AUC as named vector\n    \n  } else {\n    # For multi-class classification, use one-vs-all approach\n    roc_data_list &lt;- list()\n    auc &lt;- setNames(rep(NA, length(classes)), classes)  # Initialize a named vector for AUC\n    \n    # Loop through each class and calculate sensitivity and specificity\n    for (class_name in classes) {\n      binary_labels &lt;- ifelse(true_labels == class_name, 1, 0)\n      pos_prob &lt;- predicted_probs[, class_name]\n      \n      # Compute ROC for the current class\n      class_roc_auc_result &lt;- compute_roc_auc(binary_labels, pos_prob)\n      class_roc_data &lt;- class_roc_auc_result$roc\n      class_roc_data$class &lt;- class_name  # Add class column\n      \n      # Store ROC data and AUC for the current class\n      roc_data_list[[class_name]] &lt;- class_roc_data\n      auc[class_name] &lt;- class_roc_auc_result$auc  # Assign AUC to the named vector\n    }\n    \n    # Combine ROC results for all classes into a single data frame\n    roc_data &lt;- do.call(rbind, roc_data_list)\n  }\n  result &lt;- list(roc_data = roc_data, auc = auc)\n  class(result) &lt;- \"roc_auc\"\n  return(result)\n}"
  },
  {
    "objectID": "posts/Naive bayes model/Naive bayes model.html#function-plot.roc_auc",
    "href": "posts/Naive bayes model/Naive bayes model.html#function-plot.roc_auc",
    "title": "Naive Bayes Model",
    "section": "4 Function plot.roc_auc",
    "text": "4 Function plot.roc_auc\nA ggplot2 plot displaying the ROC curves for all classes. Each class is represented by a different color, and the AUC values are shown on the plot to summarize the classifier’s performance for each class.\n\n\nCode\nplot.roc_auc &lt;- function(x, ...) {\n  # Extract ROC data and AUC values\n  roc_data &lt;- x$roc_data\n  auc_values &lt;- x$auc\n  \n  # Create a data frame for AUC values to annotate\n  auc_annotations &lt;- data.frame(\n    class = names(auc_values),\n    auc = round(auc_values, 4),\n    label = paste(names(auc_values), \": \", round(auc_values, 4), sep = \"\")\n  )\n  \n  # Plot all ROC curves, using different colors for each class\n  p &lt;- ggplot(roc_data, aes(x = FPR, y = TPR, color = class)) +\n    geom_line(linewidth = 1) +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"gray\") +\n    labs(title = \"ROC Curves for All Classes\",\n         x = \"False Positive Rate\", y = \"True Positive Rate\") +\n    theme_minimal()\n  \n  # Annotate AUC values at the top-right corner without any box or frame\n  auc_text &lt;- paste(\"AUC:\\n\", paste(auc_annotations$label, collapse = \"\\n\"))\n  \n  p &lt;- p + annotate(\"text\", x = 0.8, y = 0.6, hjust = 0,\n                    label = auc_text, size = 3, color = \"black\")\n  \n  # Display the plot\n  return(p)\n}"
  },
  {
    "objectID": "posts/Naive bayes model/Naive bayes model.html#a-real-example",
    "href": "posts/Naive bayes model/Naive bayes model.html#a-real-example",
    "title": "Naive Bayes Model",
    "section": "5 A real example",
    "text": "5 A real example\nWe apply the custom Naive Bayes classifier to the Adult dataset for classification (the data can be found in Github) . We also compare its performance in terms of speed with the naiveBayes function from the e1071 R package.\n\nlibrary(ggplot2)\ndata &lt;- read.csv(\"adult.data\",\n                 na.strings = \" ?\", header=FALSE)\nnewdata &lt;- read.table(\"adult.test\",\n                      sep=\",\", skip = 1,na.strings = \" ?\")\nnewdata$V15 &lt;- gsub(\"\\\\.$\", \"\", newdata$V15)\nsystem.time({\n  model &lt;- Bayesclasifier(data,\"V15\",alpha = 1)\n  pred &lt;- predict(model,newdata,\"raw\")  \n  roc &lt;- roc_auc(newdata$V15,pred)\n})\n#&gt;|    user  system elapsed \n#&gt;|   0.161   0.005   0.165\nlibrary(e1071)\nsystem.time({\n  model2 &lt;- e1071::naiveBayes(V15~.,data=data)\n  pred2 &lt;- predict(model2,newdata)\n})\n#&gt;|    user  system elapsed \n#&gt;|   1.334   0.009   1.347\n\nFaster than the function in e1071.\n\nconfusion_matrix(newdata$V15,pred &lt;- predict(model,newdata,\"class\"))\n#&gt;|         Predicted\n#&gt;| Actual    &lt;=50K  &gt;50K\n#&gt;|    &lt;=50K  11547   888\n#&gt;|    &gt;50K    1863  1983\n\n\nplot(roc)"
  },
  {
    "objectID": "posts/Naive bayes model/Naive bayes model.html#function-print.naivebayes_clasifier",
    "href": "posts/Naive bayes model/Naive bayes model.html#function-print.naivebayes_clasifier",
    "title": "Naive Bayes Model",
    "section": "6 Function print.naiveBayes_clasifier",
    "text": "6 Function print.naiveBayes_clasifier\nThis function prints a summary of the fitted model, including the prior probabilities, the conditional probabilities for each variable, and an indication of whether each variable is numeric or categorical.\n\n\nCode\nprint.naiveBayes_clasifier &lt;- function(model) {\n  cat(\"Naive Bayes Model\\n\")\n  cat(\"=================\\n\")\n  \n  # Print class levels\n  cat(\"\\nClass Levels:\\n\")\n  print(model$level)\n  \n  # Print prior probabilities\n  cat(\"\\nPrior Probabilities:\\n\")\n  print(model$prior)\n  \n  # Loop through the model tables to display statistics for each feature\n  cat(\"\\nFeature Statistics:\\n\")\n  for (i in seq_along(model$tables)) {\n    feature_name &lt;- names(model$tables)[i]\n    cat(\"\\nFeature:\", feature_name, \"\\n\")\n    \n    if (model$isnumeric[i]) {\n      # For numeric features, print mean and standard deviation\n      cat(\"Type: Numeric\\n\")\n      stats &lt;- model$tables[[i]]\n      print(data.frame(\n        Mean = stats[, 1], SD = stats[, 2]))\n    } else {\n      # For categorical features, print conditional probabilities\n      cat(\"Type: Categorical\\n\")\n      probs &lt;- model$tables[[i]]\n      print(as.data.frame.matrix(probs))\n    }\n  }\n  \n  cat(\"\\n=================\\n\")\n}\n\n\n\n\nCode\nprint(model)\n#&gt;| Naive Bayes Model\n#&gt;| =================\n#&gt;| \n#&gt;| Class Levels:\n#&gt;| [1] \" &lt;=50K\" \" &gt;50K\" \n#&gt;| \n#&gt;| Prior Probabilities:\n#&gt;| label\n#&gt;|     &lt;=50K      &gt;50K \n#&gt;| 0.7591904 0.2408096 \n#&gt;| \n#&gt;| Feature Statistics:\n#&gt;| \n#&gt;| Feature: V1 \n#&gt;| Type: Numeric\n#&gt;|            Mean       SD\n#&gt;|  &lt;=50K 36.78374 14.02009\n#&gt;|  &gt;50K  44.24984 10.51903\n#&gt;| \n#&gt;| Feature: V2 \n#&gt;| Type: Categorical\n#&gt;|         Federal-gov  Local-gov  Never-worked   Private  Self-emp-inc\n#&gt;|  &lt;=50K   0.02385959 0.05972986  0.0003235199 0.7171627    0.02001779\n#&gt;|  &gt;50K    0.04739457 0.07873614  0.0001274048 0.6324373    0.07937317\n#&gt;|         Self-emp-not-inc  State-gov  Without-pay\n#&gt;|  &lt;=50K        0.07351990 0.03825623 0.0006065998\n#&gt;|  &gt;50K         0.09236845 0.04510129 0.0001274048\n#&gt;| \n#&gt;| Feature: V3 \n#&gt;| Type: Numeric\n#&gt;|            Mean       SD\n#&gt;|  &lt;=50K 190340.9 106482.3\n#&gt;|  &gt;50K  188005.0 102541.8\n#&gt;| \n#&gt;| Feature: V4 \n#&gt;| Type: Categorical\n#&gt;|               10th        11th        12th      1st-4th     5th-6th     7th-8th\n#&gt;|  &lt;=50K 0.035252264 0.045116429 0.016211190 0.0065895860 0.012855757 0.024539133\n#&gt;|  &gt;50K  0.008018328 0.007763778 0.004327351 0.0008909253 0.002163676 0.005218277\n#&gt;|                9th  Assoc-acdm  Assoc-voc  Bachelors   Doctorate   HS-grad\n#&gt;|  &lt;=50K 0.019728331  0.03246281 0.04131630  0.1267384 0.004366106 0.3568483\n#&gt;|  &gt;50K  0.003563701  0.03385516 0.04607356  0.2828051 0.039073438 0.2133130\n#&gt;|           Masters   Preschool  Prof-school  Some-college\n#&gt;|  &lt;=50K 0.03092658 0.002102199  0.006225744     0.2387209\n#&gt;|  &gt;50K  0.12218404 0.000127275  0.053964618     0.1766578\n#&gt;| \n#&gt;| Feature: V5 \n#&gt;| Type: Numeric\n#&gt;|             Mean       SD\n#&gt;|  &lt;=50K  9.595065 2.436147\n#&gt;|  &gt;50K  11.611657 2.385129\n#&gt;| \n#&gt;| Feature: V6 \n#&gt;| Type: Categorical\n#&gt;|          Divorced  Married-AF-spouse  Married-civ-spouse  Married-spouse-absent\n#&gt;|  &lt;=50K 0.16099810       0.0005661827           0.3350588            0.015570025\n#&gt;|  &gt;50K  0.05912334       0.0014016310           0.8528287            0.004459735\n#&gt;|         Never-married   Separated    Widowed\n#&gt;|  &lt;=50K     0.41222146 0.038823958 0.03676143\n#&gt;|  &gt;50K      0.06269113 0.008537207 0.01095821\n#&gt;| \n#&gt;| Feature: V7 \n#&gt;| Type: Categorical\n#&gt;|         Adm-clerical  Armed-Forces  Craft-repair  Exec-managerial\n#&gt;|  &lt;=50K    0.13196410  0.0003638716     0.1282041       0.08486294\n#&gt;|  &gt;50K     0.06467218  0.0002546149     0.1183959       0.25066836\n#&gt;|         Farming-fishing  Handlers-cleaners  Machine-op-inspct  Other-service\n#&gt;|  &lt;=50K       0.03557856         0.05195278         0.07087410     0.12771893\n#&gt;|  &gt;50K        0.01476766         0.01107575         0.03195417     0.01756843\n#&gt;|         Priv-house-serv  Prof-specialty  Protective-serv     Sales\n#&gt;|  &lt;=50K     0.0060240964      0.09226166       0.01774885 0.1078677\n#&gt;|  &gt;50K      0.0002546149      0.23679185       0.02698918 0.1252705\n#&gt;|         Tech-support  Transport-moving\n#&gt;|  &lt;=50K    0.02611789        0.05166977\n#&gt;|  &gt;50K     0.03615532        0.04086569\n#&gt;| \n#&gt;| Feature: V8 \n#&gt;| Type: Categorical\n#&gt;|          Husband  Not-in-family  Other-relative   Own-child  Unmarried\n#&gt;|  &lt;=50K 0.2942651      0.3013023     0.038218879 0.202297177 0.13059128\n#&gt;|  &gt;50K  0.7543010      0.1092137     0.004842615 0.008665732 0.02790875\n#&gt;|              Wife\n#&gt;|  &lt;=50K 0.03332524\n#&gt;|  &gt;50K  0.09506818\n#&gt;| \n#&gt;| Feature: V9 \n#&gt;| Type: Categorical\n#&gt;|         Amer-Indian-Eskimo  Asian-Pac-Islander      Black       Other     White\n#&gt;|  &lt;=50K         0.011162791          0.03089990 0.11073812 0.009989889 0.8372093\n#&gt;|  &gt;50K          0.004715779          0.03530461 0.04945195 0.003313790 0.9072139\n#&gt;| \n#&gt;| Feature: V10 \n#&gt;| Type: Categorical\n#&gt;|           Female      Male\n#&gt;|  &lt;=50K 0.3880349 0.6119651\n#&gt;|  &gt;50K  0.1504526 0.8495474\n#&gt;| \n#&gt;| Feature: V11 \n#&gt;| Type: Numeric\n#&gt;|             Mean         SD\n#&gt;|  &lt;=50K  148.7525   963.1393\n#&gt;|  &gt;50K  4006.1425 14570.3790\n#&gt;| \n#&gt;| Feature: V12 \n#&gt;| Type: Numeric\n#&gt;|             Mean       SD\n#&gt;|  &lt;=50K  53.14292 310.7558\n#&gt;|  &gt;50K  195.00153 595.4876\n#&gt;| \n#&gt;| Feature: V13 \n#&gt;| Type: Numeric\n#&gt;|            Mean       SD\n#&gt;|  &lt;=50K 38.84021 12.31899\n#&gt;|  &gt;50K  45.47303 11.01297\n#&gt;| \n#&gt;| Feature: V14 \n#&gt;| Type: Categorical\n#&gt;|            Cambodia      Canada       China     Columbia        Cuba\n#&gt;|  &lt;=50K 0.0005250192 0.003352046 0.002261621 0.0023423933 0.002867412\n#&gt;|  &gt;50K  0.0010149708 0.005074854 0.002664298 0.0003806141 0.003298655\n#&gt;|         Dominican-Republic      Ecuador  El-Salvador     England       France\n#&gt;|  &lt;=50K        0.0027866403 0.0010096523  0.003957837 0.002463552 0.0007269496\n#&gt;|  &gt;50K         0.0003806141 0.0006343568  0.001268714 0.003933012 0.0016493276\n#&gt;|            Germany      Greece    Guatemala        Haiti  Holand-Netherlands\n#&gt;|  &lt;=50K 0.003796293 0.000888494 0.0025039376 0.0016558297        8.077218e-05\n#&gt;|  &gt;50K  0.005709211 0.001141842 0.0005074854 0.0006343568        1.268714e-04\n#&gt;|            Honduras         Hong      Hungary       India        Iran\n#&gt;|  &lt;=50K 0.0005250192 0.0006057914 0.0004442470 0.002463552 0.001050038\n#&gt;|  &gt;50K  0.0002537427 0.0008880995 0.0005074854 0.005201725 0.002410556\n#&gt;|             Ireland       Italy     Jamaica       Japan         Laos\n#&gt;|  &lt;=50K 0.0008077218 0.001978918 0.002907799 0.001575058 0.0006865635\n#&gt;|  &gt;50K  0.0007612281 0.003298655 0.001395585 0.003171784 0.0003806141\n#&gt;|             Mexico    Nicaragua  Outlying-US(Guam-USVI-etc)         Peru\n#&gt;|  &lt;=50K 0.024675902 0.0013327410                0.0006057914 0.0012115827\n#&gt;|  &gt;50K  0.004313626 0.0003806141                0.0001268714 0.0003806141\n#&gt;|         Philippines      Poland     Portugal  Puerto-Rico     Scotland\n#&gt;|  &lt;=50K  0.005573281 0.001978918 0.0013731271  0.004159767 0.0004038609\n#&gt;|  &gt;50K   0.007866024 0.001649328 0.0006343568  0.001649328 0.0005074854\n#&gt;|              South      Taiwan     Thailand  Trinadad&Tobago  United-States\n#&gt;|  &lt;=50K 0.002625096 0.001292355 0.0006461775     0.0007269496      0.8884940\n#&gt;|  &gt;50K  0.002156813 0.002664298 0.0005074854     0.0003806141      0.9099213\n#&gt;|             Vietnam   Yugoslavia\n#&gt;|  &lt;=50K 0.0025443237 0.0004442470\n#&gt;|  &gt;50K  0.0007612281 0.0008880995\n#&gt;| \n#&gt;| ================="
  },
  {
    "objectID": "posts/Naive bayes model/Naive bayes model.html#supervisor-provided-r-code-for-naive-bayes-classifier",
    "href": "posts/Naive bayes model/Naive bayes model.html#supervisor-provided-r-code-for-naive-bayes-classifier",
    "title": "Naive Bayes Model",
    "section": "7 Supervisor-provided R code for Naive Bayes Classifier",
    "text": "7 Supervisor-provided R code for Naive Bayes Classifier\nThe followings are the code provided from my supervisor, which suit for the adult data only.\n\n\nCode\n\nptm &lt;- proc.time()\n\n#### read training and tesing\nD = read.table(\"adult.data\",sep=\",\",stringsAsFactors = F)\nDt = read.table(\"adult.test\",sep=\",\",skip=1,stringsAsFactors = F)\n\ncolnames(D)= c(\"age\",\"workclass\",\"fnlwgt\",\"education\",\"education_num\",\"matrital_status\",\n               \"occupation\",\"relationship\",\"race\",\"sex\",\"capital_gain\",\"capital_loss\",\n               \"hours_per_week\",\"native_country/region\",\"salary\")\ncolnames(Dt) = colnames(D)\n\n#### extract discrete variables\ndis.indice = c(2,4,6,7,8,9,10,14)\ncon.indice = c(1,3,5,11,12,13)\nis.class.zero = (D[,15]==\" &lt;=50K\")\n\nYt = rep(0,nrow(Dt))\nYt[Dt[,15]==\" &gt;50K.\"] = 1\n\n#### training and testing\nalpha = 1\nn0 = sum(is.class.zero)\nn1 = sum(!is.class.zero)\n\nP0 = matrix(0,nrow=nrow(Dt),ncol=(ncol(Dt)-1))\nP1 = P0\n\n##### for discrete variables\nfor (i in dis.indice){\n  x = c(D[is.class.zero,i],D[!is.class.zero,i],Dt[,i])\n  x = as.factor(x)\n  \n  xnames = levels(x)\n  loc = which(xnames==\" ?\")\n  if (length(loc)!=0){\n    xnames = xnames[-loc]\n  }\n  d = length(xnames)\n  \n  #### training and testing at the same time\n  for (j in 1:d){\n    P0[Dt[,i]==xnames[j],i] = log((sum(D[is.class.zero,i]==xnames[j])+alpha)/(n0+d*alpha))\n    P1[Dt[,i]==xnames[j],i] = log((sum(D[!is.class.zero,i]==xnames[j])+alpha)/(n1+d*alpha))\n  }\n}\n\n\n##### for continuous variables\nfor (i in con.indice){\n  sigma0 = sd(D[is.class.zero,i]); sigma1 = sd(D[!is.class.zero,i])\n  mu0 = mean(D[is.class.zero,i]); mu1 = mean(D[!is.class.zero,i])\n  P0[,i] = -log(sigma0)-(Dt[,i]-mu0)^2/sigma0^2/2\n  P1[,i] = -log(sigma1)-(Dt[,i]-mu1)^2/sigma1^2/2\n}\n\n#### NB result\nP0 = cbind(P0,rep(log(n0/(n0+n1)),nrow(P0)))\nP1 = cbind(P1,rep(log(n1/(n0+n1)),nrow(P1)))\ndiff.P = P0 - P1\ncolnames(diff.P) = c(\"age\",\"workclass\",\"fnlwgt\",\"education\",\"education_num\",\"matrital_status\",\n  \"occupation\",\"relationship\",\"race\",\"sex\",\"capital_gain\",\"capital_loss\",\n  \"hours_per_week\",\"native_country/region\",\"prior\")\n\ndiff = rowSums(diff.P)          \n\n#M0 = rowSums(P0)+log(n0/(n0+n1))\n#M1 = rowSums(P1)+log(n1/(n0+n1))\n#diff = M0-M1\n\n###### plot ROC\nYt.sorted = Yt[sort(diff,index.return=T)[[\"ix\"]]]\nsen = rep(0,length(Yt.sorted)+1)\nspe = rep(sum(Yt.sorted==0),length(Yt.sorted)+1)\nfor (j in 1:length(Yt.sorted)){\n  if (Yt.sorted[j]==1){\n    sen[j+1]=sen[j]+1;spe[j+1]=spe[j]\n  }else{\n    spe[j+1]=spe[j]-1;sen[j+1]=sen[j]\n  }\n}\nsen = sen/sum(Yt.sorted==1)\nspe = spe/sum(Yt.sorted==0)\n\nauc = sum((spe[1:(length(spe)-1)]-spe[2:length(spe)])*sen[1:(length(sen)-1)])\n\n### confusion matrix\nConfmat = matrix(NA,nrow = 2,ncol = 2)\nrownames(Confmat) = c(\"&lt;=50K\",\"&gt;50K\")\ncolnames(Confmat) = c(\"Predict &lt;=50K\",\"Predict &gt;50K\")\nConfmat[\"&lt;=50K\",\"Predict &lt;=50K\"] = sum(diff&gt;0 & Yt==0)\nConfmat[\"&lt;=50K\",\"Predict &gt;50K\"] = sum(diff&lt;0 & Yt==0)\nConfmat[\"&gt;50K\",\"Predict &lt;=50K\"] = sum(diff&gt;0 & Yt==1)\nConfmat[\"&gt;50K\",\"Predict &gt;50K\"] = sum(diff&lt;0 & Yt==1)\nacc = sum(Confmat[c(1,4)])/sum(Confmat)\n\n\nResult:\n\nConfmat\n#&gt;|       Predict &lt;=50K Predict &gt;50K\n#&gt;| &lt;=50K         11547          888\n#&gt;| &gt;50K           1863         1983\ncat(\"Total accuary =\", acc)\n#&gt;| Total accuary = 0.83103\n\nproc.time() - ptm\n#&gt;|    user  system elapsed \n#&gt;|   0.221   0.011   0.233\nplot(1-spe,sen,type=\"l\",col=\"blue\",main = paste0(\"ROC curve, AUC =\",round(auc,3)),ylab = \"sensitivity\",xlab = \"1-specificity\")\nabline(a=0,b=1)"
  },
  {
    "objectID": "resource/resource.html",
    "href": "resource/resource.html",
    "title": "Some Resouces",
    "section": "",
    "text": "Homework of statistical inference chapter 8. Document\n\\(\\LaTeX\\) template of the homework can be found in GitHub."
  }
]