{"title":"Rcpp Study Record","markdown":{"yaml":{"title":"Rcpp Study Record","author":"Creo Hsia","date":"2024-10-10","description":"Record my study in Rcpp","format":{"html":{"code-copy":true,"code-overflow":"scroll","toc":true,"toc-depth":2,"number-sections":true,"editor":"visual"}},"knitr":{"opts_chunk":{"collapse":true,"comment":"#>"}},"execute":{"eval":false}},"headingText":"Rcpp","containsRefs":false,"markdown":"\n\n```{r}\n#| include: false\n```\n\n\n## Format for defining a function in Rcpp\n\nThe following code shows the basic format for defining a Rcpp function.\n\n```{Rcpp}\n#include<Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nRETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){\n\n    //do something\n\n    return RETURN_VALUE;\n}\n\n```\n\n-   `#include<Rcpp.h>` : This sentence enables us to use classes and functions defined by the Rcpp package\n\n-   `using namespace Rcpp;` : this sentence enables us to use them directly, other wise you need to declare that we use these function from package Rcpp by, e.g. `Rcpp::NumericVector`.\n\n<!-- -->\n\n-   `// [[Rcpp::export]]`：The function defined just below this sentence will be accessible from R.\n\n-   `RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){}`：We need to specify data types of functions and arguments.\n\n## Compiling the code\n\nThe function `Rcpp::sourceCpp()` will compile your source code and load the defined function into R. The below code defines a function that calculates the sum of a vector.\n\n```{Rcpp}\n//sum.cpp\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector v){\n    double sum = 0;\n    for(int i=0; i<v.length(); ++i){\n        sum += v[i];\n    }\n    return(sum);\n}\n```\n\nNow we can load it into R by\n\n```{R}\n#| eval: true\nlibrary(Rcpp)\nsourceCpp('sum.cpp')\n```\n\n## Executing the function\n\nWe can use our Rcpp functions as usual R functions\n\n```{r}\n#| eval: true\nrcpp_sum(1:10)\n```\n\n## Embedding Rcpp code in our R code\n\nWe can write Rcpp code in our R code in 3 ways.\n\n### `sourceCpp()`\n\nSave Rcpp code as string object in R and compile it with `sourceCpp()`\n\n```{r}\n#| eval: true\nsrc <-\n\"#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector v){\n  double sum = 0;\n  for(int i=0; i<v.length(); ++i){\n    sum += v[i];\n  }\n  return(sum);\n}\"\n\nsourceCpp(code = src)\nrcpp_sum(1:10)\n```\n\n### `cppFunction()`\n\nWe can omit `#include <Rcpp.h>` and `using namespase Rcpp` when we use `cppFunction()`.\n\n```{r}\n#| eval: true\nsrc <-\"double rcpp_sum(NumericVector v){\n    double sum = 0;\n    for(int i=0; i<v.length(); ++i){\n      sum += v[i];\n    }\n    return(sum);\n  }\n  \"\nRcpp::cppFunction(src)\nrcpp_sum(1:10)\n```\n\n### `evalCpp()`\n\nYou can evaluate a single C++ statement by using `evalCpp()`.\n\n```{r}\n#| eval: true\n# Showing maximum value of double.\nevalCpp('std::numeric_limits<double>::max()')\n```\n\n## C++ 11\n\nC++ 11 is a standard of C++ newly established in 2011. Many new features have been added to make C++ even easier for beginners.\n\n::: callout-important\nThe code examples in this document are written with C++11 enabled.\n:::\n\n### Enabling C++11\n\nTo enable `C++11`, add the following decription in our Rcpp code. \\> `// [[Rcpp::plugins(\"cpp11\")]]`\n\n### Recommended C++11 features\n\n#### Initializer list\n\n```{Rcpp}\n// Initialize Vector\n// The next three are the same as c (1, 2, 3).\nNumericVector v1 = NumericVector::create(1.0, 2.0, 3.0);\nNumericVector v2 = {1.0, 2.0, 3.0};\nNumericVector v3   {1.0, 2.0, 3.0}; // You can omit \"=\".\n```\n\n#### decltype\n\nBy using decltype, you can declare a variable of the same type as an existing variable.\n\n```{Rcpp}\n#| eval: false\nint i;\ndecltype(i) x; // variable \"x\" will be int\n```\n\n#### Range-vased for-loop\n\nWe can write a for statement with the same style as R.\n\n```{Rcpp}\nIntegerVector v {1,2,3};\nint sum=0;\nfor(auto& x : v) {\n  sum += x;\n}\n```\n\n> `auto& x`: The `auto&` keyword means that each element in the vector v will be referenced as x. Using & allows direct access to each element (by reference), but here it’s primarily for efficiency, so **no copy of each element is made**.\n\n#### Lambda expression\n\nIt is a function object created as an unnamed function and passed to the other function.\n\nLambda expressions are written in the form `[](){}`\n\n`[]` specifies how the lambda should access variables from the surrounding scope. Here are the different options:\n\n-   `[]` : Capture nothing. The lambda function cannot access any local variables from the surrounding scope.\n\n-   `[=]` : Capture all local variables by value. This means a copy of each variable is made, and the lambda works with the copy.\n\n-   `[&]` : Capture all local variables by reference. The lambda can modify the original variables because it’s accessing them directly.\n\n-   \\[=x, &y\\]: Capture specific variables in different ways. In this example, the variable x will be captured by value (copied), and y will be captured by reference (accessed directly).\n\nThe return type of this function object is automatically set to the type of the returned value described in `{}`. If you want to define return type explicitly, write it like `[]()->int{}`.\n\n**Examples**\n\nR example\n\n```{r}\n#| eval: true\nv <- c(1,2,3,4,5)\nA <- 2.0\nsapply(v, function(x){A*x})\n```\n\nRcpp example We save it as `lambda.cpp`\n\n```{Rcpp}\n#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::plugins(\"cpp11\")]]\n// [[Rcpp::export]]\nNumericVector rcpp_lambda_1(){\n  NumericVector v = {1,2,3,4,5};\n  double A = 2.0;\n  NumericVector res =\n    sapply(v, [&](double x){return A*x;});\n  return res;\n}\n```\n\n```{r}\n#| eval: true\nsourceCpp('lambda.cpp')\nrcpp_lambda_1()\n```\n\n## Printing Messages\n\n### `Rcout`, `Rcerr`\n\n```{Rcpp}\n#| eval: false\n\n// [[Rcpp::export]]\nvoid rcpp_rcout(NumericVector v){\n  // printing value of vector\n  Rcout << \"The value of v : \" << v << \"\\n\";\n\n  // printing error message\n  Rcerr << \"Error message\\n\";\n}\n```\n\n> This line declares a function named `rcpp_rcout` that takes a NumericVector as an argument and returns nothing (void).\n>\n> Rcout is an Rcpp-specific object similar to the standard C++ `std::cout`, but it is used for printing messages to the R console. It uses `<<` to concatenate output.\n>\n> Rcerr is similar to the standard C++ `std:cerr`, which is used for error messages and diagnostic output. Rcerr is used to send error or warning messages in R, so output sent through Rcerr might be displayed differently (in red text, depending on the R environment) to indicate an issue or warning.\n\n### `Rprintf()`, `REprintf()`\n\nThese functions are used to print formatted output to the R console. It allows you to format the output using placeholders (e.g., `%d` for integers, `%f` for floats).\n\nSyntax:\n\n```{Rcpp}\nRprintf( format, variables)\n\n```\n\nThe first argument is a format string, and subsequent arguments are the values to be inserted into the formatted string. Some format specifier is presented below:\n\n| **specifier** | **explanation** |\n|----|----|\n| `%i` | printing signed integer (`int`) |\n| `%u` | printing unsigned integer (`unsigned int`) |\n| `%f` | printing floating point number (`double`) |\n| `%e` | printing floating point number (`double`) in exponential style |\n| `%s` | printing C string (`char*`) |\n\n> Additionally, `Rprintf()` and `REprintf()` can only print data types that exist in standard C++ language, thus you cannot pass data types defined by Rcpp package (such as NumericVector) to Rprintf() directly. If you want to print the values of elements of an Rcpp vector using Rprintf(), you have to pass each element separately to it (see below).\n\n```{Rcpp}\n// [[Rcpp::export]]\nvoid rcpp_rprintf(NumericVector v){\n    // printing values of all the elements of Rcpp vector  \n    for(int i=0; i<v.length(); ++i){\n        Rprintf(\"the value of v[%i] : %f \\n\", i, v[i]);\n    }\n}\n```\n\n## Data Types\n\nAll the basic data types and data structures provided by R are available in Rcpp. By using these data types, you can directly access the objects that exist in R. \\### Vector and Matrix Following seven data types are often used in R.\n\n`logical` `integer` `numeric` `complex` `character` `Date` `POSIXct` \\### Vector and matrix There are vector type and matrix types in Rcpp corresponding to those of R.\n\nThe table below presents the correspondence of data types between R/Rcpp/C++.\n\n| **Value** | **R vector** | **Rcpp vector** | **Rcpp matrix** | **Rcpp scalar** | **C++ scalar** |\n|----|----|----|----|----|----|\n| Logical | `logical` | `LogicalVector` | `LogicalMatrix` | \\- | `bool` |\n| Integer | `integer` | `IntegerVector` | `IntegerMatrix` | \\- | `int` |\n| Real | `numeric` | `NumericVector` | `NumericMatrix` | \\- | `double` |\n| Complex | `complex` | `ComplexVector` | `ComplexMatrix` | `Rcomplex` | `complex` |\n| String | `character` | `CharacterVector` (`StringVector`) | `CharacterMatrix` (`StringMatrix`) | `String` | `string` |\n| Date | `Date` | `DateVector` | \\- | `Date` | \\- |\n| Datetime | `POSIXct` | `DatetimeVector` | \\- | `Datetime` | `time_t` |\n\n### data.frame, list, S3, S4\n\nOther than `Vector` and `Matrix`, There are several data structures in R such as `data.frame`, `list`, `S3 class` and `S4 class`. You can handle all of these data structures in Rcpp.\n\n| **R**        | **Rcpp**    |\n|--------------|-------------|\n| `data.frame` | `DataFrame` |\n| `list`       | `List`      |\n| S3 class     | `List`      |\n| S4 class     | `S4`        |\n\nIn Rcpp, Vector, DataFrame, List are all implemented as kinds of vectors. Namely, Vector is a vector that its elements are scalar values, DataFrame is a vector that its elements are Vectors, List is a vector that its elements are any kind of data types. Thus, Vector, DataFrame, List has many common member functions in Rcpp.\n\n## Vector\n\n### Creating vector object\n\nWe can create vector objects in several ways.\n\n```{Rcpp}\n// Create a Vector object equivalent to\n// v <- rep(0, 3)\nNumericVector v (3);\n\n// v <- rep(1, 3)\nNumericVector v (3,1);\n\n// v <- c(1,2,3) \n// C++11 Initializer list\nNumericVector v = {1,2,3}; \n\n// v <- c(1,2,3)\nNumericVector v = NumericVector::create(1,2,3);\n\n// v <- c(x=1, y=2, z=3)\nNumericVector v =\n  NumericVector::create(Named(\"x\",1), Named(\"y\")=2 , _[\"z\"]=3);\n```\n\n### Accessing vector elements\n\nThis Rcpp function demonstrates various ways of **accessing and modifying** elements of a NumericVector in R using different types of indices (numerical, integer, character, and logical).\n\n```{Rcpp}\n// [[Rcpp::export]]\nvoid rcpp_vector_access() {\n  // Creating vector\n  NumericVector v  {10, 20, 30, 40, 50};\n```\n\n> A NumericVector v is created with five numeric elements: {10, 20, 30, 40, 50}.\n\n```{Rcpp}\n#| eval: false \n\n\n  // Setting element names\n  v.names() = CharacterVector({\"A\", \"B\", \"C\", \"D\", \"E\"});\n```\n\n> This sets the names for the elements in the NumericVector v. After this, the vector looks like:\n\n```{r}\n#| eval: false\n\nA  B  C  D  E \n10 20 30 40 50\n```\n\n```{r}\n#| eval: false\n\n  // Preparing vector for access\n  NumericVector numeric = {1, 3};\n  IntegerVector integer = {1, 3};\n  CharacterVector character = {\"B\", \"D\"};\n  LogicalVector logical = {false, true, false, true, false};\n```\n\n> These vectors (numeric, integer, character, and logical) are created for indexing:\n\n```{r}\n#| eval: false\n\n\n  // Getting values of vector elements\n  double x1 = v[0];             // Accesses the first element (10)\n  double x2 = v[\"A\"];           // Accesses the element with name \"A\" (also 10)\n  NumericVector res1 = v[numeric];    // Gets elements at indices 2 and 4 (20, 40)\n  NumericVector res2 = v[integer];    // Same as res1 (20, 40)\n  NumericVector res3 = v[character];  // Gets elements named \"B\" and \"D\" (20, 40)\n  NumericVector res4 = v[logical];    // Gets elements at positions 2 and 4 (20, 40)\n```\n\n> -   v\\[0\\]: Accesses the first element using numeric indexing (zero-based indexing in C++).\n> -   v\\[\"A\"\\]: Accesses the element with the name \"A\", which corresponds to the first element (10).\n> -   v\\[numeric\\]**,** v\\[integer\\]**,** v\\[character\\]**,** v\\[logical\\]: Accesses multiple elements at once using vectors of different types (numeric, integer, character, logical). All of these access the same elements, 20 and 40, but using different methods of indexing.\n\n::: callout-important\nwhen accessing elements from a container like NumericVector in Rcpp, you typically need to declare the type of the variable that will hold the result first.\n:::\n\n```{r}\n#| eval: false\n\n\n  // Assigning values to vector elements\n  v[0]   = 100;                 // Replaces the first element with 100\n  v[\"A\"] = 100;                 // Replaces the element named \"A\" with 100\n  NumericVector v2 {100, 200};   // A new vector {100, 200}\n  v[numeric]   = v2;            // Replaces elements at indices 2 and 4 with 100, 200\n  v[integer]   = v2;            // Same as above (2nd and 4th elements)\n  v[character] = v2;            // Replaces elements named \"B\" and \"D\" with 100, 200\n  v[logical]   = v2;            // Replaces elements at logical `true` positions (2nd and 4th) with 100, 200\n}\n```\n\n> -   `v[0] = 100`: Changes the first element to 100.\n> -   `v[\"A\"] = 100`: Changes the element named \"A\" (which is the same as the first element) to 100.\n> -   `v[numeric] = v2`, `v[integer] = v2`, `v[character] = v2`, `v[logical] = v2`: These lines replace the selected elements (based on various indexing methods) with the values from the new vector v2 ({100, 200}).\n\n::: callout-important\nwhen modifying elements of a vector or container in Rcpp, you must ensure that the new elements are of the same type as the original container.\n:::\n\n### Methods\n\nMethods are functions that are attached to an individual object. You can call methods function `f()` of object `v` in the form `v.f()`.\n\n```{r}\nNumericVector v = {1,2,3,4,5};\n\n// Calling member function\nint n = v.length(); // 5\n```\n\nThe `vector` object in Rcpp has methods functiongs listed below\n\n| Method | Description |\n|----|----|\n| `size()` | Returns the number of elements of this vector object. |\n| `names()` | Returns the element names of this vector object as `CharacterVector`. |\n| `offset(name)`, `findName(name)` | Returns the numerical index of the element specified by the character string `name`. |\n| `offset(i)` | Returns the numerical index of the element specified by the numerical index `i` after bounds check. |\n| `fill(x)` | Fills all the elements of this vector object with scalar value `x`. |\n| `sort()` | Returns a vector that sorts this vector object in ascending order. |\n| `assign(first_it, last_it)` | Assigns values specified by the iterator `first_it` and `last_it` to this vector object. |\n| `push_back(x)` | Appends a scalar value `x` to the end of this vector object. |\n| `push_back(x, name)` | Appends a scalar value `x` to the end of this vector object and sets the name of the element as `name`. |\n| `push_front(x)` | Appends a scalar value `x` to the front of this vector object. |\n| `push_front(x, name)` | Appends a scalar value `x` to the front of this vector object and sets the name of the element as `name`. |\n| `begin()` | Returns an iterator pointing to the first element of this vector object. |\n| `end()` | Returns an iterator pointing to the end (one past the last element) of this vector object. |\n| `cbegin()` | Returns a const iterator pointing to the first element of this vector. |\n| `cend()` | Returns a const iterator pointing to the end (one past the last element) of this vector. |\n| `insert(i, x)` | Inserts a scalar value `x` at the position specified by the numerical index `i`. |\n| `insert(it, x)` | Inserts a scalar value `x` at the position pointed to by the iterator `it`. |\n| `erase(i)` | Erases the element at the position specified by the numerical index `i`. |\n| `erase(it)` | Erases the element at the position pointed to by the iterator `it`. |\n| `erase(first_i, last_i)` | Erases elements from the position specified by numerical index `first_i` to `last_i`. |\n| `erase(first_it, last_it)` | Erases elements from the position specified by the iterators `first_it` to `last_it`. |\n| `containsElementNamed(name)` | Returns `true` if this vector contains an element with the name specified by the character string `name`. |\n\n### Static methods\n\nA **static methods** is a function that belongs to a **class** rather than an instance of the class. This means that you don’t need to create an object (or instance) of the class to call the function; you can call it directly using the class name.\n\n-   Static member functions are called using the class name followed by the ::\n-   Example in Rcpp: NumericVector::create(). Here, create() is a static member function of the class NumericVector, which means you can call it directly using the class name (NumericVector), without creating a NumericVector object first.\n\n## Matrix\n\n`Matrix` objects can be created in several ways.\n\n```{r}\n// Create a Matrix object equivalent to\n// m <- matrix(0, nrow=2, ncol=2)\nNumericMatrix m1( 2 );\n\n// m <- matrix(0, nrow=2, ncol=3)\nNumericMatrix m2( 2 , 3 );\n\n// m <- matrix(v, nrow=2, ncol=3)\nNumericMatrix m3( 2 , 3 , v.begin() );\n```\n\nIn addition, a matrix object in R is actually a vector that the number of rows and columns are set in the attribute `dim`.\n\nThus, if you create a vector with attribute `dim` in Rcpp and return it to R, it will be treated as a matrix.\n\n```{r}\n#| eval: true\nmat <- '#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::export]]\nNumericVector rcpp_matrix(){\n    // Creating a vector object\n    NumericVector v = {1,2,3,4};\n\n    // Set the number of rows and columns to attribute dim of the vector object.\n    v.attr(\"dim\") = Dimension(2, 2);\n\n    // Return the vector to R\n    return v;\n}'\nsourceCpp(code=mat)\nrcpp_matrix()\n```\n\n> Even if you set a value to attribute `dim` of a Vector object, the type of the object remains a `Vector` type in Rcpp code. Thus, if you want to convert it to `Matrix` type in Rcpp, you need to use `as<T>()` function.\n\n```{r}\n#| eval: false\n// Set number of rows and columns to attribute dim\nv.attr(\"dim\") = Dimension(2, 2);\n\n// Converting to Rcpp Matrix type\nNumericMatrix m = as<NumericMatrix>(v);\n```\n\n### Accessing to Matrix elements\n\nBy using the `()` operator, you can get from and assign to the values of elements of a Matrix object by specifying its column number and row number.\n\n```{r}\n// Creating a 5x5 numerical matrix\nNumericMatrix m( 5, 5 );\n\n// Retrieving the element of row 0 and column 2\ndouble x = m( 0 , 2 );\n\n```\n\n> -   This line retrieves the element at **row 0**, **column 2** of the matrix m and stores it in the variable x.\n> -   The **parentheses** m(0, 2) are used for **element access** in the matrix, similar to m\\[0, 2\\] in R.\n\n```{r}\nNumericVector v = m( 0 , _ );\n```\n\n> -   This line copies all the values in **row 0** (i.e., the entire first row) of the matrix m into the vector v.\n> -   The underscore \\_ is a placeholder that represents “all elements” in the corresponding dimension.\n\n```{r}\nNumericVector v = m( _ , 2 );\n```\n\n> -   This line copies all the values in **column 2** (i.e., the third column) of the matrix m into the vector v.\n\n```{r}\nNumericMatrix m2 = m( Range(0,1), Range(2,3) );\n```\n\n> -   This line copies a submatrix of m consisting of the values in **rows 0 and 1** (first and second rows) and **columns 2 and 3** (third and fourth columns) into a new matrix m2. `Range(0,1)` specifies that rows 0 and 1 should be selected, and `Range(2,3)` specifies that columns 2 and 3 should be selected.\n\n```{r}\nm[5]; // This points to the same element as m(0,1)\n```\n\n> This line demonstrates **linear indexing** into the matrix. While NumericMatrix is a two-dimensional structure, it can also be treated like a **1D** array when accessed with square brackets `[]`.\n\n### Accessing as reference to row, column and sub matrix\n\nRcpp also provides types that hold “references” to specific parts of a matrix.\n\n1.  Referencing a Column:\n\n```{r}\nNumericMatrix::Column col = m( _ , 1 );\n```\n\n> -   m(\\_, 1): This accesses column 1 of the matrix m (zero-based indexing, so it refers to the second column).\n> -   NumericMatrix::Column: This type is a reference to a specific column of the matrix. It doesn’t create a copy of the column but rather provides direct access to the elements in column 1.\n\n2.  Referencing a Row:\n\n```{r}\nNumericMatrix::Row row = m( 1 , _ );\n```\n\n> -   `m(1,_)`: Thisaccesses **row 1** of the matrix m\n> -   `NumericMatrix::Row`: This type is a reference to a specific row of the matrix.\n\n3.  Referencing a Submatrix\n\n```{r}\nNumericMatrix::Sub sub = m( Range(0,1) , Range(2,3) );\n```\n\n> -   `Range(0,1)`: This specifies the range of rows to select (rows 0 and 1, the first two rows).\n> -   `Range(2,3)`: This specifies the range of columns to select (columns 2 and 3, the third and fourth columns).\n> -   `NumericMatrix::Sub`: This type is a reference to a submatrix of m. It references the elements in the submatrix defined by the row and column ranges.\n\n### Methods\n\nSince Matrix is actually `Vector`, Matrix basically has the same member functions as `Vector`. Thus, member functions unique to `Matrix` are only presented below.\n\n| Method | Description |\n|----|----|\n| `nrow()` or `rows()` | Returns the number of rows. |\n| `ncol()` or `cols()` | Returns the number of columns. |\n| `row(i)` | Returns a reference `Vector::Row` to the `i`-th row. |\n| `column(i)` | Returns a reference `Vector::Column` to the `i`-th column. |\n| `fill_diag(x)` | Fills the diagonal elements with the scalar value `x`. |\n| `offset(i, j)` | Returns the numerical index in the original vector of the matrix corresponding to the element at row `i` and column `j`. |\n\n### Static menmber functions\n\nMatrix basically has the same static member function as Vector. The static member functions unique to Matrix are shown below. `Matrix::diag( size, x )`: Returns a diagonal matrix whose number of rows and columns equals to “size” and the value of the diagonal element is “x”.\n\n```{r}\ncppFunction(\"\nNumericMatrix create_diag_matrix(int size, double x) {\n    // Create a diagonal matrix of the given size with x on the diagonal\n    NumericMatrix mat = NumericMatrix::diag(size, x);\n    return mat;\n}\")\ncreate_diag_matrix(5,2)\n```\n\n::: callout-important\n`x` is a scalar value that will be placed along the diagonal of the matrix.\n:::\n\n### Other functions related to Matrix\n\n1.  rownames\n\n-   get the row name of matrix `m`:\n\n```{r}\nCharacterVector ch = rownames(m);\n```\n\n-   set the row name of matrix `m`:\n\n```{r}\nrownames(m) = ch\n```\n\n2.  colnames\n\n-   get the column name of matrix `m`:\n\n```{r}\nCharacterVector ch = colnames(m);\n```\n\n-   set the column name of matrix `m`:\n\n```{r}\ncolnames(m) = ch\n```\n\n3.  transpose return the transposed matrix of matirx `m`:\n\n```{r}\ntranspose(m)\n```\n\n## Vector operations\n\n### Arithmetic operations\n\nBy using the `+` `-` `*` `/` operator you can perform elementwise arithmetic operations between vectors of the same length.\n\n```{r}\nNumericVector x ;\nNumericVector y ;\n```\n\nVector and vector operation\n\n```{r}\n// Vector and vector operation\nNumericVector res = x + y ;\nNumericVector res = x - y ;\nNumericVector res = x * y ;\nNumericVector res = x / y ;\n```\n\nVector and scalar operation\n\n```{r}\n// Vector and scalar operation\nNumericVector res = x   + 2.0 ;\nNumericVector res = 2.0 - x;\nNumericVector res = y   * 2.0 ;\nNumericVector res = 2.0 / y;\n```\n\nExpression and expression operation\n\n```{r}\nNumericVector res = x * y + y / 2.0 ;\nNumericVector res = x * ( y - 2.0 ) ;\nNumericVector res = x / ( y * y ) ;\n```\n\nThe `-` operator inverts the sign.\n\n```{r}\nNumericVector res = -x ;\n```\n\n### Comparison operations\n\nComparison of vectors using `==` `!` `=` `<` `>` `>=` `<=` operators produces **logical vectors**. You can also access vector elements using logical vectors.\n\nComparison of vector and vector\n\n```{r}\nLogicalVector res = x < y ;\nLogicalVector res = x > y ;\nLogicalVector res = x <= y ;\nLogicalVector res = x >= y ;\nLogicalVector res = x == y ;\nLogicalVector res = x != y ;\n```\n\nComparison of vector and scalar\n\n```{r}\nLogicalVector res = x < 2 ;\nLogicalVector res = 2 > x;\nLogicalVector res = y <= 2 ;\nLogicalVector res = 2 != y;\n```\n\nComparison of expression and expression\n\n```{r}\nLogicalVector res = ( x + y ) < ( x*x ) ;\nLogicalVector res = ( x + y ) >= ( x*x ) ;\nLogicalVector res = ( x + y ) == ( x*x ) ;\n```\n\n`!(...)`: The logical NOT operator `!` negates the result of the comparison. In other words, it turns TRUE into FALSE and FALSE into TRUE.\n\n```{r}\nLogicalVector res = !(x < y);\n```\n\nAccessing the elements of the vector using logical vectors.\n\n```{r}\nNumericVector res = x[x < 2];\n```\n\n## Logical operations\n\n### Logical Vector\n\nAlthough in C++ the **boolean type** (bool) has only two possible values, `true (1)` and `false (0)`, R’s logical vectors have a third possible value: `NA` (missing or undefined). Because C++ bool can’t represent this third state, Rcpp **uses integers to represent the elements of R’s LogicalVector**.\n\nIn Rcpp, elements of a **LogicalVector** are stored as integers to accommodate the extra `NA` value. Specifically, these values are represented as: + TRUE: 1 (same as C++ true) + FALSE: 0 (same as C++ false) + NA: NA_LOGICAL, which is a special constant defined as the minimum value of an integer: -2147483648 (the smallest value for a 32-bit signed integer).\n\n### Logical operations\n\nUse the operator `&` (logical product) `|` (logical sum) `!` (Logical negation) for the logical operation for each element of LogicalVector.\n\n```{r}\nLogicalVector v1 = {1,1,0,0};\nLogicalVector v2 = {1,0,1,0};\n\nLogicalVector res1 = v1 & v2;\nLogicalVector res2 = v1 | v2;\nLogicalVector res3 = !(v1 | v2);\n\nRcout << res1 << \"\\n\"; // 1 0 0 0\nRcout << res2 << \"\\n\"; // 1 1 1 0\nRcout << res3 << \"\\n\"; // 0 0 0 1\n```\n\n### Function that receives LogicalVector\n\n#### `all()` and `any()`\n\nExamples of functions that receive LogicalVector are `all()`, `any()` and `ifelse()`.\n\n-   `all(v)` returns `TRUE` when all elements of `v` are `TRUE`, and `any(v)` returns `TRUE` if any of `v`'s elements are `TRUE`.\n\nIn Rcpp, the return type of both all() and any() is not a simple bool, but a more complex type called `SingleLogicalResult`.\n\nThis type can represent not only `TRUE` or `FALSE`, but also `NA` (the third possible logical value in R). As a result, the return value of `all()` or `any()` cannot be directly used in a conditional statement like an `if` statement in C++.\n\nTo convert the `SingleLogicalResult` from `all()` or `any()` into a bool, Rcpp provides helper functions: + is_true(): Returns true if the result is TRUE. + is_false(): Returns true if the result is FALSE. + is_na(): Returns true if the result is NA.\n\n#### `ifelse()`\n\n`ifelse (v, x1, x2)` receives the logical vector `v`, and returns the corresponding element of `x1` when the element of `v` is `TRUE` and the corresponding element of `x2` when it is `FALSE`.\n\n> `x1` and `x2` must either be `scalars` or `vectors`. If they are vectors, their length must match the **length of v**. This ensures that there is a corresponding element in `x1` or `x2` for each element in `v`.\n\n```{r}\nNumericVector v1;\nNumericVector v2;\n//Number of elements of vector\nint n = v1.length();\n```\n\nIn case, both x1 and x2 are scalar\n\n```{r}\nIntegerVector res1     = ifelse( v1>v2, 1, 0);\nNumericVector res2     = ifelse( v1>v2, 1.0, 0.0);\n```\n\n::: callout-important\nSince `ifelse()` does not work with a scalar `character string`, we need to use a string vector whose values of elements are all the same.\n:::\n\n```{r}\nCharacterVector chr_v1 = rep(CharacterVector(\"T\"), n);\nCharacterVector chr_v2 = rep(CharacterVector(\"F\"), n);\nCharacterVector res3   = ifelse( v1>v2, chr_v1, chr_v2);\n```\n\nIn case, `x1` and `x2` are `vector` and `scalar`\n\n```{r}\nIntegerVector res4 = ifelse(v1 > v2, int_v1, 0);\nNumericVector res5 = ifelse(v1 > v2, num_v1, 0.0);\nCharacterVector res6 = ifelse(v1 > v2, chr_v1, Rf_mkChar(\"F\")); // Note\n```\n\n> -   For `integer` and `numeric` vectors, the `scalar` values (0 and 0.0) are recycled as needed\n> -   For `character` vectors, you cannot directly use a scalar string like `\"F\"`; instead, you use `Rf_mkChar(\"F\")`, which creates an internal SEXP (R object) representing the string \"F\".\n\n## Data frame\n\n### Creating DataFrame\n\nIn Rcpp, `DataFrame` is implemented as a kind of vector. In other words, `Vector` is a vector whose element is **scalar** value, while `DataFrame` is a vector whose elements are Vectors of the same length.\n\n`DataFrame::create()` is used to create a DataFrame object.\n\n```{r}\n// Creating DataFrame df from Vector v1, v2\nDataFrame df = DataFrame::create(v1, v2);\n```\n\nAlso, use `Named()` or `_[]` if you want to specify column names when creating DataFrame　object.\n\n```{r}\n// When giving names to columns\nDataFrame df = DataFrame::create( Named(\"V1\") = v1 , _[\"V2\"] = v2 );\n```\n\n::: callout-warning\nWhen you create a DataFrame with `DataFrame::create()`, the value of the originalVector element will **not be duplicated** in the columns of the DataFrame, but the columns will be the **“reference”** to the original Vector. Therefore, changing the value of the original Vector changes the value of the columns. To avoid this, use `clone()`.\n:::\n\n```{r}\ndf <- '#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::export]]\nDataFrame rcpp_df(){\n  // Creating vector v\n  NumericVector v = {1,2};\n  // Creating DataFrame df\n  DataFrame df = DataFrame::create( Named(\"V1\") = v,         // simple assign\n                                    Named(\"V2\") = clone(v)); // using clone()\n  // Changing vector v\n  v = v * 2;\n  return df;\n}'\nsourceCpp(code=df)\nrcpp_df()\n```\n\n### Accessing DataFrame elements\n\nWhen you access a specific column of a DataFrame in Rcpp, that column is temporarily assigned to a `Vector` object. The Vector object allows you to manipulate or access the values of that column as if it were a separate vector.\n\n::: callout-warning\nAs with DataFrame creation, assigning aDataFrame column to Vector in the above way will not copy the column value to Vector object, but it will be a “reference” to the column. Therefore, when you change the values of Vector object, the content of the column will also be changed.\n:::\n\n#### Accessing by Numeric, String, or Logical Vectors\n\nYou can specify which column of the `DataFrame` you want to access using different types of vectors:\n\n-   `Numeric Vector` (Column Number):You can specify a column by its index (0-based). Example: df\\[0\\] would return the first column.\n\n-   `String Vector` (Column Name):You can access a column by its name using a string, which is more intuitive and readable when dealing with named columns.\n\n-   Logical Vector: Each element of the logical vector corresponds to whether a column should be included (`TRUE`) or excluded (`FALSE`). The length of the logical vector must **match the number of columns** in the data frame.\n\n### Member functions\n\n| Method | Description |\n|----|----|\n| `nrows()` | Returns the number of rows. |\n| `ncol()` | Returns the number of columns. |\n| `length()` | Returns the number of columns. |\n| `size()` | Returns the number of columns. |\n| `names()` | Returns the column names as a `CharacterVector`. |\n| `offset(name)` or `findName(name)` | Returns the numerical index of the column with the name specified by the string `name`. |\n| `fill(v)` | Fills all the columns of this `DataFrame` with the `Vector` `v`. |\n| `assign(first_it, last_it)` | Assigns columns in the range specified by the iterators `first_it` and `last_it` to this `DataFrame`. |\n| `push_back(v)` | Adds `Vector v` to the end of the `DataFrame`. |\n| `push_back(v, name)` | Appends a `Vector v` to the end of the `DataFrame` and specifies the name of the added column with the string `name`. |\n| `push_front(x)` | Appends a `Vector v` at the beginning of this `DataFrame`. |\n| `push_front(x, name)` | Appends a `Vector v` at the beginning of this `DataFrame` and specifies the name of the added column with the string `name`. |\n| `begin()` | Returns an iterator pointing to the first column of this `DataFrame`. |\n| `end()` | Returns an iterator pointing to the end of this `DataFrame`. |\n| `insert(it, v)` | Adds `Vector v` to this `DataFrame` at the position pointed by the iterator `it` and returns an iterator to that element. |\n| `erase(i)` | Deletes the `i`-th column of this `DataFrame` and returns an iterator to the column just after the erased column. |\n| `erase(it)` | Deletes the column specified by the iterator `it` and returns an iterator to the column just after the erased column. |\n| `erase(first_i, last_i)` | Deletes columns from `first_i` to `last_i - 1` and returns an iterator to the column just after the erased columns. |\n| `erase(first_it, last_it)` | Deletes the range of columns specified by the iterators `first_it` to `last_it - 1` and returns an iterator to the column just after the erased columns. |\n| `containsElementNamed(name)` | Returns `true` if this `DataFrame` has a column with the name specified by the string `name`. |\n| `inherits(str)` | Returns `true` if the attribute \"class\" of this object contains the string `str`. |\n\n## List\n\nIn Rcpp, `List` is implemented as a kind of `vector`. In other words, Vector is a vector whose element is scalar value, while **List is a vector whose elements are any kinds of data types**.\n\n### Creating List object\n\nTo create a List object we use the `List::create()` function. Also, to specify the element name when creating List, use `Named()` function or `_[]`.\n\n```{r}\n// Create list L from vector v1, v2\nList L = List::create(v1, v2);\n\n// When giving names to elements\nList L = List::create(Named(\"name1\") = v1 , _[\"name2\"] = v2);\n```\n\n::: callout-warning\nWhen you create a `List` with `DataFrame::create()`, the value of the originalVector element will **not be duplicated** but the elements will be the **“reference”** to the original Vector. Therefore, changing the value of the original Vector changes the value of the list. To avoid this, use `clone()`.\n:::\n\n### Accessing List elements\n\nWhen accessing a specific element of List, we **assign** it to the other object and **access it via that object**.\n\nThe elements of List can be specified by numerical index, element names and logical vector.\n\n### Member functions\n\n`List` has the same member functions as `Vector`\n\n## ``` S3``S4 ``` class\n\nThe `S3` class is actually a list whose attribute class has its own value.\n\nWe use an example to demonstrate how to use it in Rcpp\n\n```{r}\ndouble rcpp_rmse(List lm_model) {\n    // Since S3 is a list, data type of the argument is specified as List.\n```\n\n> **S3 objects** in R, such as objects created by `lm()`, are typically lists with an additional `class attribute`. Since an S3 object is fundamentally a list, in Rcpp, we can use the List data type to receive it.\n\n```{r}\nif (! lm_model.inherits(\"lm\")) stop(\"Input must be a lm() model object.\");\n```\n\n> The `inherits(\"lm\")` function checks whether the input object (the list) belongs to the `lm` class. This ensures that the input object is an lm object.\n\n```{r}\n    // Extracting residuals (i.e. actual - prediction) from the S3 object\n    NumericVector resid  = lm_model[\"residuals\"];\n```\n\n> -   In an `lm` object, residuals are stored in the \"residuals\" component.\n> -   Since the S3 object is a `list`, we can access the \"residuals\" component using list-like indexing (lm_model\\[\"residuals\"\\]), which extracts the residuals as a NumericVector in Rcpp.\n\n```{r}\n    // Number of elements of the residual vector\n    R_xlen_t n = resid.length();\n```\n\n> -   The `length()` function is used to get the number of elements in the resid vector (i.e., the number of residuals).\n> -   `R_xlen_t` is a type that represents the length of vectors in R. It is typically used in Rcpp when dealing with vector lengths.\n\n::: callout-tips\n`R_xlen_t` is large enough to handle **very long vectors**, which is crucial when you’re working with vectors whose length might **exceed the range of a standard integer** (which is 2\\^31 - 1 in R, roughly 2 billion).\n:::\n\n```{r}\n    // The sum of squares of the residual vector\n    double rmse(0.0);\n    for(double& r : resid){\n        rmse += r*r;\n    }\n\n    // Divide the residual sum of squares by the number of elements and take the square root\n    return(sqrt((1.0/n)*rmse));\n}\n```\n\n### `S4` class\n\nwait to update.\n\n## String\n\n`String` is a scalar type corresponding to the element of `CharacterVector`. String can also handle `NA` values (`NA_STRING`) which are not supported by the C character string `char*` and the C++ string `std::string`.\n\n### Creating String object\n\nThere are three main ways to create a String object. Each approach reflects different sources for creating the String object:\n\n1.  Creating a String from a `C/C++ String` (`Character Pointer` or `std::string`):\n\n```{r}\n// Create String from C-style string\nString s1 = \"Hello, world!\";\n\n// Create String from std::string\nstd::string cpp_str = \"C++ string\";\nString s2 = cpp_str;\n```\n\n> -   s1 is created from a **C-style** string (`\"Hello, world!\"`).\n> -   s2 is created from a **C++** string (`std::string`).\n\n2.  Creating a String from Another String Object:\n\n-   You can create a new String object by copying an existing String object in Rcpp.\n\n```{r}\nString s1 = \"Original string\";\n\n// Create a new String from another String object\nString s2 = s1;\n```\n\n3.  Creating a String from an Element of a `CharacterVector`:\n\n```{r}\nCharacterVector cv = CharacterVector::create(\"one\", \"two\", \"three\");\n\n// Create a String from the second element of the CharacterVector\nString s = cv[1];  // Note: 0-based indexing, so this accesses \"two\"\n```\n\n### Operators\n\nIn Rcpp, the String class supports the `+=` operator, which allows you to **append** another string (or string-like object) to an existing String object.\n\n```{r}\n// Creating String object\nString s(\"A\");\n\n// Conbining a string\ns += \"B\";\n\nRcout << s << \"\\n\"; \n// \"AB\"\n```\n\n### Member functions\n\n| Method | Description |\n|----|----|\n| `replace_first(str, new_str)` | Replace the first substring that matches the string `str` with the string `new_str`. |\n| `replace_last(str, new_str)` | Replace the last substring that matches the string `str` with the string `new_str`. |\n| `replace_all(str, new_str)` | Replace all substrings that match the string `str` with the string `new_str`. |\n| `push_back(str)` | Combine the string `str` to the end of this `String` object. (Same as `+=` operator) |\n| `push_front(str)` | Combine the string `str` at the beginning of this `String` object. |\n| `set_na()` | Set NA value to this `String` object. |\n| `get_cstring()` | Convert the string of this `String` object into a C character string constant (`const char*`) and return it. |\n| `get_encoding()` | Returns the character encoding. The encoding is represented by `cettype_t`. |\n| `set_encoding(enc)` | Set the character encoding specified by `cettype_t`. |\n\n## Date and DateVector\n\n### Creating Date objects\n\nThe following codes illustrates different ways to create a Date object in Rcpp, representing a specific date.\n\n```{r}\nDate d;  // \"1970-01-01\"\n```\n\n> -   `Date d`; creates a Date object d that represents the epoch date \"1970-01-01\", which is considered the default starting point for dates in many computing systems, including R.\n\n```{r}\nDate d(1);  // \"1970-01-01\" + 1 day\n```\n\n> -   `Date d(1)`; creates a Date object d that represents one day after the epoch date.\n\n```{r}\nDate d(1.1);  // \"1970-01-01\" + ceil(1.1) day\n```\n\n> -   `Date d(1.1)`; creates a Date object `d` that represents 1.1 days after “1970-01-01”. The number is rounded up (`using ceil()`), so it is treated as 2 days after “1970-01-01”.\n\n```{r}\nDate d(\"2000-01-01\", \"%Y-%m-%d\");  // Date specified by a string with a format\n```\n\n> This creates a Date object `d` from a string `\"2000-01-01\"` with the format `\"%Y-%m-%d\"`\n\nDate from `Day`, `Month`, and `Year` `(mm/dd/yyyy)`:\n\n```{r}\nDate d(1, 2, 2000);  // 2000-01-02 (mon, day, year)\n```\n\n### Operators\n\n`Date` has operators `+`, `-`, `<`, `>`, `>=`, `<=`, `==`, `!=`.\n\nBy using these operators, you can perform addition of days (`+`), difference calculation of date (`-`), and comparison of dates (`<`, `<=`, `>`, `>=`, `==`, `!=`) . \\### Member functions\n\n| Method | Description |\n|----|----|\n| `format()` | Returns the date as a `std::string` using the same specification as base R. The default format is `YYYY-MM-DD`. |\n| `getDay()` | Returns the day of the date. |\n| `getMonth()` | Returns the month of the date. |\n| `getYear()` | Returns the year of the date. |\n| `getWeekday()` | Returns the day of the week as an int. (`1:Sun`, `2:Mon`, `3:Tue`, `4:Wed`, `5:Thu`, `6:Sat`). |\n| `getYearday()` | Returns the number of the date through the year (with January 1st as 1 and December 31st as 365). |\n| `is_na()` | Returns `true` if this object is NA. |\n\n### DateVector subsetting\n\nIn Rcpp, both `DateVector` and `DateTimeVector` are internally stored as numeric types (specifically, doubles). This design simplifies certain internal calculations but can be confusing when working with individual elements of these vectors.\n\nThis behavior is important because when you subset a DateVector using the `[]` operator, you extract a `double`, which represents the date as the number of days since the `epoch date` (1970-01-01).\n\nTo work with individual `Date` or `DateTime` objects from a `DateVector` or `DateTimeVector`, you need to explicitly cast or convert the extracted element back into a `Date` or `DateTime` object.\n\nExample:\n\n```{r}\n// [[Rcpp::export]]\nvoid print_year_of_date(DateVector dates) {\n    for (int i = 0; i < dates.size(); ++i) {\n        // Convert the extracted double to a Date object\n        Date single_date = dates[i];  // Convert double to Date\n        int year = single_date.getYear();  // Now you can call getYear()\n        Rcpp::Rcout << \"Year: \" << year << std::endl;\n    }\n}\n```\n\n> -   dates\\[i\\] returns a double by default.\n> -   Date single_date = dates\\[i\\];: We explicitly convert the double value to a Date object, allowing us to use the getYear() method.\n\n## RObject\n\nThe `RObject` type in Rcpp is a flexible and general-purpose type that can **represent any kind of R object**.\n\nHere is an example that demonstrates how RObject can be used in Rcpp to accept and handle different types of R objects.\n\n```{r}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nvoid handle_any_type(RObject obj) {\n    // Check if the object is a NumericVector\n    if (obj.is<NumericVector>()) {\n        NumericVector num_vec = as<NumericVector>(obj);\n        Rcpp::Rcout << \"Numeric Vector: \" << num_vec << std::endl;\n    } \n    // Check if the object is a CharacterVector\n    else if (obj.is<CharacterVector>()) {\n        CharacterVector char_vec = as<CharacterVector>(obj);\n        Rcpp::Rcout << \"Character Vector: \" << char_vec << std::endl;\n    } \n    // Check if the object is a List\n    else if (obj.is<List>()) {\n        List lst = as<List>(obj);\n        Rcpp::Rcout << \"List: \" << lst << std::endl;\n    } \n    // Handle unknown types\n    else {\n        Rcpp::Rcout << \"Unknown type!\" << std::endl;\n    }\n}\n```\n\n### Cnversion using `as<>()`:\n\n-   `as<>()` is a template function in Rcpp that allows you to convert an `RObject` to a more specific type when you know the type of the object or have determined it dynamically.\n\n```{r}\nNumericVector num_vec = as<NumericVector>(obj);  // Convert RObject to NumericVector\n```\n\n> This converts the RObject into a NumericVector when you are sure that it contains a numeric vector.\n\n## Cautions in handling Rcpp objects\n\n### Assigning between vectors\n\nIn Rcpp, when you assign an object (like a vector, list, or matrix) v1 to another object v2 using the `=` operator (e.g., `v2 = v1`;), **no deep copy** is made. Instead, v2 **becomes an alias** to v1, meaning that both v1 and v2 point to **the same underlying data in memory**.\n\nIf you want v2 to be a completely independent copy of `v1`, so that changes to `v1` do not affect `v2`, you need to perform a **deep copy**. In Rcpp, you can use the `clone()` function to create a deep copy.\n\n### Data type of numerical index\n\nYou should use `R_xlen_t` as data type for numerical index or the number of elements to support **long vector** in your Rcpp code.\n\n### Return type of operator `[]`\n\nIn Rcpp, when you access an element of a vector with \\[\\] or (), you do not directly get the element as its native type (e.g., double, int, or String). Instead, you get a Vector::Proxy object. This Proxy object acts as an intermediary that allows you to modify the vector element directly or retrieve its value, but **it is not the same as the element’s actual type**.\n\nTo resolve this, you either: + **Assign** `v[i]` to a new object of the expected type. + **Convert** the Proxy to the native type using `as<T>()`.\n\n## R-like functions\n\nHere is a list of Rcpp functions similar to R functions.\n\nIf you know for certain that your vector **does not contain any NA values**, you can optimize your code by using the `noNA()` function. `noNA()` marks the vector as guaranteed to be free of `NA` values, which allows Rcpp to skip `NA` checks and perform calculations more efficiently.\n\n> List is too long to illustrate.\n\n## Probability distribution\n\nIn Rcpp, probability distribution functions exist in two different namespaces:\n\n1.  `Rcpp::` namespace:\n\n-   Functions in this namespace return vectors.\n\n-   These functions are designed to be similar to their counterparts in base R. You can pass a vector of values to these functions and they will return a vector of results.\n\n2.  `R::` namespace:\n\n-   Functions in this namespace return scalar values (a single value).\n-   If you only need a single value from the distribution function, using the R:: version of the function can be more efficient because it avoids the overhead of vectorization.\n\n```{r}\nsort_cpp <- '#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::export]]\nNumericVector sort_numeric_vector(NumericVector x) {\n    std::sort(x.begin(), x.end());\n    return x;\n}'\nsourceCpp(code=sort_cpp)\n\n```\n","srcMarkdownNoYaml":"\n\n```{r}\n#| include: false\n```\n\n# Rcpp\n\n## Format for defining a function in Rcpp\n\nThe following code shows the basic format for defining a Rcpp function.\n\n```{Rcpp}\n#include<Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nRETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){\n\n    //do something\n\n    return RETURN_VALUE;\n}\n\n```\n\n-   `#include<Rcpp.h>` : This sentence enables us to use classes and functions defined by the Rcpp package\n\n-   `using namespace Rcpp;` : this sentence enables us to use them directly, other wise you need to declare that we use these function from package Rcpp by, e.g. `Rcpp::NumericVector`.\n\n<!-- -->\n\n-   `// [[Rcpp::export]]`：The function defined just below this sentence will be accessible from R.\n\n-   `RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){}`：We need to specify data types of functions and arguments.\n\n## Compiling the code\n\nThe function `Rcpp::sourceCpp()` will compile your source code and load the defined function into R. The below code defines a function that calculates the sum of a vector.\n\n```{Rcpp}\n//sum.cpp\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector v){\n    double sum = 0;\n    for(int i=0; i<v.length(); ++i){\n        sum += v[i];\n    }\n    return(sum);\n}\n```\n\nNow we can load it into R by\n\n```{R}\n#| eval: true\nlibrary(Rcpp)\nsourceCpp('sum.cpp')\n```\n\n## Executing the function\n\nWe can use our Rcpp functions as usual R functions\n\n```{r}\n#| eval: true\nrcpp_sum(1:10)\n```\n\n## Embedding Rcpp code in our R code\n\nWe can write Rcpp code in our R code in 3 ways.\n\n### `sourceCpp()`\n\nSave Rcpp code as string object in R and compile it with `sourceCpp()`\n\n```{r}\n#| eval: true\nsrc <-\n\"#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector v){\n  double sum = 0;\n  for(int i=0; i<v.length(); ++i){\n    sum += v[i];\n  }\n  return(sum);\n}\"\n\nsourceCpp(code = src)\nrcpp_sum(1:10)\n```\n\n### `cppFunction()`\n\nWe can omit `#include <Rcpp.h>` and `using namespase Rcpp` when we use `cppFunction()`.\n\n```{r}\n#| eval: true\nsrc <-\"double rcpp_sum(NumericVector v){\n    double sum = 0;\n    for(int i=0; i<v.length(); ++i){\n      sum += v[i];\n    }\n    return(sum);\n  }\n  \"\nRcpp::cppFunction(src)\nrcpp_sum(1:10)\n```\n\n### `evalCpp()`\n\nYou can evaluate a single C++ statement by using `evalCpp()`.\n\n```{r}\n#| eval: true\n# Showing maximum value of double.\nevalCpp('std::numeric_limits<double>::max()')\n```\n\n## C++ 11\n\nC++ 11 is a standard of C++ newly established in 2011. Many new features have been added to make C++ even easier for beginners.\n\n::: callout-important\nThe code examples in this document are written with C++11 enabled.\n:::\n\n### Enabling C++11\n\nTo enable `C++11`, add the following decription in our Rcpp code. \\> `// [[Rcpp::plugins(\"cpp11\")]]`\n\n### Recommended C++11 features\n\n#### Initializer list\n\n```{Rcpp}\n// Initialize Vector\n// The next three are the same as c (1, 2, 3).\nNumericVector v1 = NumericVector::create(1.0, 2.0, 3.0);\nNumericVector v2 = {1.0, 2.0, 3.0};\nNumericVector v3   {1.0, 2.0, 3.0}; // You can omit \"=\".\n```\n\n#### decltype\n\nBy using decltype, you can declare a variable of the same type as an existing variable.\n\n```{Rcpp}\n#| eval: false\nint i;\ndecltype(i) x; // variable \"x\" will be int\n```\n\n#### Range-vased for-loop\n\nWe can write a for statement with the same style as R.\n\n```{Rcpp}\nIntegerVector v {1,2,3};\nint sum=0;\nfor(auto& x : v) {\n  sum += x;\n}\n```\n\n> `auto& x`: The `auto&` keyword means that each element in the vector v will be referenced as x. Using & allows direct access to each element (by reference), but here it’s primarily for efficiency, so **no copy of each element is made**.\n\n#### Lambda expression\n\nIt is a function object created as an unnamed function and passed to the other function.\n\nLambda expressions are written in the form `[](){}`\n\n`[]` specifies how the lambda should access variables from the surrounding scope. Here are the different options:\n\n-   `[]` : Capture nothing. The lambda function cannot access any local variables from the surrounding scope.\n\n-   `[=]` : Capture all local variables by value. This means a copy of each variable is made, and the lambda works with the copy.\n\n-   `[&]` : Capture all local variables by reference. The lambda can modify the original variables because it’s accessing them directly.\n\n-   \\[=x, &y\\]: Capture specific variables in different ways. In this example, the variable x will be captured by value (copied), and y will be captured by reference (accessed directly).\n\nThe return type of this function object is automatically set to the type of the returned value described in `{}`. If you want to define return type explicitly, write it like `[]()->int{}`.\n\n**Examples**\n\nR example\n\n```{r}\n#| eval: true\nv <- c(1,2,3,4,5)\nA <- 2.0\nsapply(v, function(x){A*x})\n```\n\nRcpp example We save it as `lambda.cpp`\n\n```{Rcpp}\n#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::plugins(\"cpp11\")]]\n// [[Rcpp::export]]\nNumericVector rcpp_lambda_1(){\n  NumericVector v = {1,2,3,4,5};\n  double A = 2.0;\n  NumericVector res =\n    sapply(v, [&](double x){return A*x;});\n  return res;\n}\n```\n\n```{r}\n#| eval: true\nsourceCpp('lambda.cpp')\nrcpp_lambda_1()\n```\n\n## Printing Messages\n\n### `Rcout`, `Rcerr`\n\n```{Rcpp}\n#| eval: false\n\n// [[Rcpp::export]]\nvoid rcpp_rcout(NumericVector v){\n  // printing value of vector\n  Rcout << \"The value of v : \" << v << \"\\n\";\n\n  // printing error message\n  Rcerr << \"Error message\\n\";\n}\n```\n\n> This line declares a function named `rcpp_rcout` that takes a NumericVector as an argument and returns nothing (void).\n>\n> Rcout is an Rcpp-specific object similar to the standard C++ `std::cout`, but it is used for printing messages to the R console. It uses `<<` to concatenate output.\n>\n> Rcerr is similar to the standard C++ `std:cerr`, which is used for error messages and diagnostic output. Rcerr is used to send error or warning messages in R, so output sent through Rcerr might be displayed differently (in red text, depending on the R environment) to indicate an issue or warning.\n\n### `Rprintf()`, `REprintf()`\n\nThese functions are used to print formatted output to the R console. It allows you to format the output using placeholders (e.g., `%d` for integers, `%f` for floats).\n\nSyntax:\n\n```{Rcpp}\nRprintf( format, variables)\n\n```\n\nThe first argument is a format string, and subsequent arguments are the values to be inserted into the formatted string. Some format specifier is presented below:\n\n| **specifier** | **explanation** |\n|----|----|\n| `%i` | printing signed integer (`int`) |\n| `%u` | printing unsigned integer (`unsigned int`) |\n| `%f` | printing floating point number (`double`) |\n| `%e` | printing floating point number (`double`) in exponential style |\n| `%s` | printing C string (`char*`) |\n\n> Additionally, `Rprintf()` and `REprintf()` can only print data types that exist in standard C++ language, thus you cannot pass data types defined by Rcpp package (such as NumericVector) to Rprintf() directly. If you want to print the values of elements of an Rcpp vector using Rprintf(), you have to pass each element separately to it (see below).\n\n```{Rcpp}\n// [[Rcpp::export]]\nvoid rcpp_rprintf(NumericVector v){\n    // printing values of all the elements of Rcpp vector  \n    for(int i=0; i<v.length(); ++i){\n        Rprintf(\"the value of v[%i] : %f \\n\", i, v[i]);\n    }\n}\n```\n\n## Data Types\n\nAll the basic data types and data structures provided by R are available in Rcpp. By using these data types, you can directly access the objects that exist in R. \\### Vector and Matrix Following seven data types are often used in R.\n\n`logical` `integer` `numeric` `complex` `character` `Date` `POSIXct` \\### Vector and matrix There are vector type and matrix types in Rcpp corresponding to those of R.\n\nThe table below presents the correspondence of data types between R/Rcpp/C++.\n\n| **Value** | **R vector** | **Rcpp vector** | **Rcpp matrix** | **Rcpp scalar** | **C++ scalar** |\n|----|----|----|----|----|----|\n| Logical | `logical` | `LogicalVector` | `LogicalMatrix` | \\- | `bool` |\n| Integer | `integer` | `IntegerVector` | `IntegerMatrix` | \\- | `int` |\n| Real | `numeric` | `NumericVector` | `NumericMatrix` | \\- | `double` |\n| Complex | `complex` | `ComplexVector` | `ComplexMatrix` | `Rcomplex` | `complex` |\n| String | `character` | `CharacterVector` (`StringVector`) | `CharacterMatrix` (`StringMatrix`) | `String` | `string` |\n| Date | `Date` | `DateVector` | \\- | `Date` | \\- |\n| Datetime | `POSIXct` | `DatetimeVector` | \\- | `Datetime` | `time_t` |\n\n### data.frame, list, S3, S4\n\nOther than `Vector` and `Matrix`, There are several data structures in R such as `data.frame`, `list`, `S3 class` and `S4 class`. You can handle all of these data structures in Rcpp.\n\n| **R**        | **Rcpp**    |\n|--------------|-------------|\n| `data.frame` | `DataFrame` |\n| `list`       | `List`      |\n| S3 class     | `List`      |\n| S4 class     | `S4`        |\n\nIn Rcpp, Vector, DataFrame, List are all implemented as kinds of vectors. Namely, Vector is a vector that its elements are scalar values, DataFrame is a vector that its elements are Vectors, List is a vector that its elements are any kind of data types. Thus, Vector, DataFrame, List has many common member functions in Rcpp.\n\n## Vector\n\n### Creating vector object\n\nWe can create vector objects in several ways.\n\n```{Rcpp}\n// Create a Vector object equivalent to\n// v <- rep(0, 3)\nNumericVector v (3);\n\n// v <- rep(1, 3)\nNumericVector v (3,1);\n\n// v <- c(1,2,3) \n// C++11 Initializer list\nNumericVector v = {1,2,3}; \n\n// v <- c(1,2,3)\nNumericVector v = NumericVector::create(1,2,3);\n\n// v <- c(x=1, y=2, z=3)\nNumericVector v =\n  NumericVector::create(Named(\"x\",1), Named(\"y\")=2 , _[\"z\"]=3);\n```\n\n### Accessing vector elements\n\nThis Rcpp function demonstrates various ways of **accessing and modifying** elements of a NumericVector in R using different types of indices (numerical, integer, character, and logical).\n\n```{Rcpp}\n// [[Rcpp::export]]\nvoid rcpp_vector_access() {\n  // Creating vector\n  NumericVector v  {10, 20, 30, 40, 50};\n```\n\n> A NumericVector v is created with five numeric elements: {10, 20, 30, 40, 50}.\n\n```{Rcpp}\n#| eval: false \n\n\n  // Setting element names\n  v.names() = CharacterVector({\"A\", \"B\", \"C\", \"D\", \"E\"});\n```\n\n> This sets the names for the elements in the NumericVector v. After this, the vector looks like:\n\n```{r}\n#| eval: false\n\nA  B  C  D  E \n10 20 30 40 50\n```\n\n```{r}\n#| eval: false\n\n  // Preparing vector for access\n  NumericVector numeric = {1, 3};\n  IntegerVector integer = {1, 3};\n  CharacterVector character = {\"B\", \"D\"};\n  LogicalVector logical = {false, true, false, true, false};\n```\n\n> These vectors (numeric, integer, character, and logical) are created for indexing:\n\n```{r}\n#| eval: false\n\n\n  // Getting values of vector elements\n  double x1 = v[0];             // Accesses the first element (10)\n  double x2 = v[\"A\"];           // Accesses the element with name \"A\" (also 10)\n  NumericVector res1 = v[numeric];    // Gets elements at indices 2 and 4 (20, 40)\n  NumericVector res2 = v[integer];    // Same as res1 (20, 40)\n  NumericVector res3 = v[character];  // Gets elements named \"B\" and \"D\" (20, 40)\n  NumericVector res4 = v[logical];    // Gets elements at positions 2 and 4 (20, 40)\n```\n\n> -   v\\[0\\]: Accesses the first element using numeric indexing (zero-based indexing in C++).\n> -   v\\[\"A\"\\]: Accesses the element with the name \"A\", which corresponds to the first element (10).\n> -   v\\[numeric\\]**,** v\\[integer\\]**,** v\\[character\\]**,** v\\[logical\\]: Accesses multiple elements at once using vectors of different types (numeric, integer, character, logical). All of these access the same elements, 20 and 40, but using different methods of indexing.\n\n::: callout-important\nwhen accessing elements from a container like NumericVector in Rcpp, you typically need to declare the type of the variable that will hold the result first.\n:::\n\n```{r}\n#| eval: false\n\n\n  // Assigning values to vector elements\n  v[0]   = 100;                 // Replaces the first element with 100\n  v[\"A\"] = 100;                 // Replaces the element named \"A\" with 100\n  NumericVector v2 {100, 200};   // A new vector {100, 200}\n  v[numeric]   = v2;            // Replaces elements at indices 2 and 4 with 100, 200\n  v[integer]   = v2;            // Same as above (2nd and 4th elements)\n  v[character] = v2;            // Replaces elements named \"B\" and \"D\" with 100, 200\n  v[logical]   = v2;            // Replaces elements at logical `true` positions (2nd and 4th) with 100, 200\n}\n```\n\n> -   `v[0] = 100`: Changes the first element to 100.\n> -   `v[\"A\"] = 100`: Changes the element named \"A\" (which is the same as the first element) to 100.\n> -   `v[numeric] = v2`, `v[integer] = v2`, `v[character] = v2`, `v[logical] = v2`: These lines replace the selected elements (based on various indexing methods) with the values from the new vector v2 ({100, 200}).\n\n::: callout-important\nwhen modifying elements of a vector or container in Rcpp, you must ensure that the new elements are of the same type as the original container.\n:::\n\n### Methods\n\nMethods are functions that are attached to an individual object. You can call methods function `f()` of object `v` in the form `v.f()`.\n\n```{r}\nNumericVector v = {1,2,3,4,5};\n\n// Calling member function\nint n = v.length(); // 5\n```\n\nThe `vector` object in Rcpp has methods functiongs listed below\n\n| Method | Description |\n|----|----|\n| `size()` | Returns the number of elements of this vector object. |\n| `names()` | Returns the element names of this vector object as `CharacterVector`. |\n| `offset(name)`, `findName(name)` | Returns the numerical index of the element specified by the character string `name`. |\n| `offset(i)` | Returns the numerical index of the element specified by the numerical index `i` after bounds check. |\n| `fill(x)` | Fills all the elements of this vector object with scalar value `x`. |\n| `sort()` | Returns a vector that sorts this vector object in ascending order. |\n| `assign(first_it, last_it)` | Assigns values specified by the iterator `first_it` and `last_it` to this vector object. |\n| `push_back(x)` | Appends a scalar value `x` to the end of this vector object. |\n| `push_back(x, name)` | Appends a scalar value `x` to the end of this vector object and sets the name of the element as `name`. |\n| `push_front(x)` | Appends a scalar value `x` to the front of this vector object. |\n| `push_front(x, name)` | Appends a scalar value `x` to the front of this vector object and sets the name of the element as `name`. |\n| `begin()` | Returns an iterator pointing to the first element of this vector object. |\n| `end()` | Returns an iterator pointing to the end (one past the last element) of this vector object. |\n| `cbegin()` | Returns a const iterator pointing to the first element of this vector. |\n| `cend()` | Returns a const iterator pointing to the end (one past the last element) of this vector. |\n| `insert(i, x)` | Inserts a scalar value `x` at the position specified by the numerical index `i`. |\n| `insert(it, x)` | Inserts a scalar value `x` at the position pointed to by the iterator `it`. |\n| `erase(i)` | Erases the element at the position specified by the numerical index `i`. |\n| `erase(it)` | Erases the element at the position pointed to by the iterator `it`. |\n| `erase(first_i, last_i)` | Erases elements from the position specified by numerical index `first_i` to `last_i`. |\n| `erase(first_it, last_it)` | Erases elements from the position specified by the iterators `first_it` to `last_it`. |\n| `containsElementNamed(name)` | Returns `true` if this vector contains an element with the name specified by the character string `name`. |\n\n### Static methods\n\nA **static methods** is a function that belongs to a **class** rather than an instance of the class. This means that you don’t need to create an object (or instance) of the class to call the function; you can call it directly using the class name.\n\n-   Static member functions are called using the class name followed by the ::\n-   Example in Rcpp: NumericVector::create(). Here, create() is a static member function of the class NumericVector, which means you can call it directly using the class name (NumericVector), without creating a NumericVector object first.\n\n## Matrix\n\n`Matrix` objects can be created in several ways.\n\n```{r}\n// Create a Matrix object equivalent to\n// m <- matrix(0, nrow=2, ncol=2)\nNumericMatrix m1( 2 );\n\n// m <- matrix(0, nrow=2, ncol=3)\nNumericMatrix m2( 2 , 3 );\n\n// m <- matrix(v, nrow=2, ncol=3)\nNumericMatrix m3( 2 , 3 , v.begin() );\n```\n\nIn addition, a matrix object in R is actually a vector that the number of rows and columns are set in the attribute `dim`.\n\nThus, if you create a vector with attribute `dim` in Rcpp and return it to R, it will be treated as a matrix.\n\n```{r}\n#| eval: true\nmat <- '#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::export]]\nNumericVector rcpp_matrix(){\n    // Creating a vector object\n    NumericVector v = {1,2,3,4};\n\n    // Set the number of rows and columns to attribute dim of the vector object.\n    v.attr(\"dim\") = Dimension(2, 2);\n\n    // Return the vector to R\n    return v;\n}'\nsourceCpp(code=mat)\nrcpp_matrix()\n```\n\n> Even if you set a value to attribute `dim` of a Vector object, the type of the object remains a `Vector` type in Rcpp code. Thus, if you want to convert it to `Matrix` type in Rcpp, you need to use `as<T>()` function.\n\n```{r}\n#| eval: false\n// Set number of rows and columns to attribute dim\nv.attr(\"dim\") = Dimension(2, 2);\n\n// Converting to Rcpp Matrix type\nNumericMatrix m = as<NumericMatrix>(v);\n```\n\n### Accessing to Matrix elements\n\nBy using the `()` operator, you can get from and assign to the values of elements of a Matrix object by specifying its column number and row number.\n\n```{r}\n// Creating a 5x5 numerical matrix\nNumericMatrix m( 5, 5 );\n\n// Retrieving the element of row 0 and column 2\ndouble x = m( 0 , 2 );\n\n```\n\n> -   This line retrieves the element at **row 0**, **column 2** of the matrix m and stores it in the variable x.\n> -   The **parentheses** m(0, 2) are used for **element access** in the matrix, similar to m\\[0, 2\\] in R.\n\n```{r}\nNumericVector v = m( 0 , _ );\n```\n\n> -   This line copies all the values in **row 0** (i.e., the entire first row) of the matrix m into the vector v.\n> -   The underscore \\_ is a placeholder that represents “all elements” in the corresponding dimension.\n\n```{r}\nNumericVector v = m( _ , 2 );\n```\n\n> -   This line copies all the values in **column 2** (i.e., the third column) of the matrix m into the vector v.\n\n```{r}\nNumericMatrix m2 = m( Range(0,1), Range(2,3) );\n```\n\n> -   This line copies a submatrix of m consisting of the values in **rows 0 and 1** (first and second rows) and **columns 2 and 3** (third and fourth columns) into a new matrix m2. `Range(0,1)` specifies that rows 0 and 1 should be selected, and `Range(2,3)` specifies that columns 2 and 3 should be selected.\n\n```{r}\nm[5]; // This points to the same element as m(0,1)\n```\n\n> This line demonstrates **linear indexing** into the matrix. While NumericMatrix is a two-dimensional structure, it can also be treated like a **1D** array when accessed with square brackets `[]`.\n\n### Accessing as reference to row, column and sub matrix\n\nRcpp also provides types that hold “references” to specific parts of a matrix.\n\n1.  Referencing a Column:\n\n```{r}\nNumericMatrix::Column col = m( _ , 1 );\n```\n\n> -   m(\\_, 1): This accesses column 1 of the matrix m (zero-based indexing, so it refers to the second column).\n> -   NumericMatrix::Column: This type is a reference to a specific column of the matrix. It doesn’t create a copy of the column but rather provides direct access to the elements in column 1.\n\n2.  Referencing a Row:\n\n```{r}\nNumericMatrix::Row row = m( 1 , _ );\n```\n\n> -   `m(1,_)`: Thisaccesses **row 1** of the matrix m\n> -   `NumericMatrix::Row`: This type is a reference to a specific row of the matrix.\n\n3.  Referencing a Submatrix\n\n```{r}\nNumericMatrix::Sub sub = m( Range(0,1) , Range(2,3) );\n```\n\n> -   `Range(0,1)`: This specifies the range of rows to select (rows 0 and 1, the first two rows).\n> -   `Range(2,3)`: This specifies the range of columns to select (columns 2 and 3, the third and fourth columns).\n> -   `NumericMatrix::Sub`: This type is a reference to a submatrix of m. It references the elements in the submatrix defined by the row and column ranges.\n\n### Methods\n\nSince Matrix is actually `Vector`, Matrix basically has the same member functions as `Vector`. Thus, member functions unique to `Matrix` are only presented below.\n\n| Method | Description |\n|----|----|\n| `nrow()` or `rows()` | Returns the number of rows. |\n| `ncol()` or `cols()` | Returns the number of columns. |\n| `row(i)` | Returns a reference `Vector::Row` to the `i`-th row. |\n| `column(i)` | Returns a reference `Vector::Column` to the `i`-th column. |\n| `fill_diag(x)` | Fills the diagonal elements with the scalar value `x`. |\n| `offset(i, j)` | Returns the numerical index in the original vector of the matrix corresponding to the element at row `i` and column `j`. |\n\n### Static menmber functions\n\nMatrix basically has the same static member function as Vector. The static member functions unique to Matrix are shown below. `Matrix::diag( size, x )`: Returns a diagonal matrix whose number of rows and columns equals to “size” and the value of the diagonal element is “x”.\n\n```{r}\ncppFunction(\"\nNumericMatrix create_diag_matrix(int size, double x) {\n    // Create a diagonal matrix of the given size with x on the diagonal\n    NumericMatrix mat = NumericMatrix::diag(size, x);\n    return mat;\n}\")\ncreate_diag_matrix(5,2)\n```\n\n::: callout-important\n`x` is a scalar value that will be placed along the diagonal of the matrix.\n:::\n\n### Other functions related to Matrix\n\n1.  rownames\n\n-   get the row name of matrix `m`:\n\n```{r}\nCharacterVector ch = rownames(m);\n```\n\n-   set the row name of matrix `m`:\n\n```{r}\nrownames(m) = ch\n```\n\n2.  colnames\n\n-   get the column name of matrix `m`:\n\n```{r}\nCharacterVector ch = colnames(m);\n```\n\n-   set the column name of matrix `m`:\n\n```{r}\ncolnames(m) = ch\n```\n\n3.  transpose return the transposed matrix of matirx `m`:\n\n```{r}\ntranspose(m)\n```\n\n## Vector operations\n\n### Arithmetic operations\n\nBy using the `+` `-` `*` `/` operator you can perform elementwise arithmetic operations between vectors of the same length.\n\n```{r}\nNumericVector x ;\nNumericVector y ;\n```\n\nVector and vector operation\n\n```{r}\n// Vector and vector operation\nNumericVector res = x + y ;\nNumericVector res = x - y ;\nNumericVector res = x * y ;\nNumericVector res = x / y ;\n```\n\nVector and scalar operation\n\n```{r}\n// Vector and scalar operation\nNumericVector res = x   + 2.0 ;\nNumericVector res = 2.0 - x;\nNumericVector res = y   * 2.0 ;\nNumericVector res = 2.0 / y;\n```\n\nExpression and expression operation\n\n```{r}\nNumericVector res = x * y + y / 2.0 ;\nNumericVector res = x * ( y - 2.0 ) ;\nNumericVector res = x / ( y * y ) ;\n```\n\nThe `-` operator inverts the sign.\n\n```{r}\nNumericVector res = -x ;\n```\n\n### Comparison operations\n\nComparison of vectors using `==` `!` `=` `<` `>` `>=` `<=` operators produces **logical vectors**. You can also access vector elements using logical vectors.\n\nComparison of vector and vector\n\n```{r}\nLogicalVector res = x < y ;\nLogicalVector res = x > y ;\nLogicalVector res = x <= y ;\nLogicalVector res = x >= y ;\nLogicalVector res = x == y ;\nLogicalVector res = x != y ;\n```\n\nComparison of vector and scalar\n\n```{r}\nLogicalVector res = x < 2 ;\nLogicalVector res = 2 > x;\nLogicalVector res = y <= 2 ;\nLogicalVector res = 2 != y;\n```\n\nComparison of expression and expression\n\n```{r}\nLogicalVector res = ( x + y ) < ( x*x ) ;\nLogicalVector res = ( x + y ) >= ( x*x ) ;\nLogicalVector res = ( x + y ) == ( x*x ) ;\n```\n\n`!(...)`: The logical NOT operator `!` negates the result of the comparison. In other words, it turns TRUE into FALSE and FALSE into TRUE.\n\n```{r}\nLogicalVector res = !(x < y);\n```\n\nAccessing the elements of the vector using logical vectors.\n\n```{r}\nNumericVector res = x[x < 2];\n```\n\n## Logical operations\n\n### Logical Vector\n\nAlthough in C++ the **boolean type** (bool) has only two possible values, `true (1)` and `false (0)`, R’s logical vectors have a third possible value: `NA` (missing or undefined). Because C++ bool can’t represent this third state, Rcpp **uses integers to represent the elements of R’s LogicalVector**.\n\nIn Rcpp, elements of a **LogicalVector** are stored as integers to accommodate the extra `NA` value. Specifically, these values are represented as: + TRUE: 1 (same as C++ true) + FALSE: 0 (same as C++ false) + NA: NA_LOGICAL, which is a special constant defined as the minimum value of an integer: -2147483648 (the smallest value for a 32-bit signed integer).\n\n### Logical operations\n\nUse the operator `&` (logical product) `|` (logical sum) `!` (Logical negation) for the logical operation for each element of LogicalVector.\n\n```{r}\nLogicalVector v1 = {1,1,0,0};\nLogicalVector v2 = {1,0,1,0};\n\nLogicalVector res1 = v1 & v2;\nLogicalVector res2 = v1 | v2;\nLogicalVector res3 = !(v1 | v2);\n\nRcout << res1 << \"\\n\"; // 1 0 0 0\nRcout << res2 << \"\\n\"; // 1 1 1 0\nRcout << res3 << \"\\n\"; // 0 0 0 1\n```\n\n### Function that receives LogicalVector\n\n#### `all()` and `any()`\n\nExamples of functions that receive LogicalVector are `all()`, `any()` and `ifelse()`.\n\n-   `all(v)` returns `TRUE` when all elements of `v` are `TRUE`, and `any(v)` returns `TRUE` if any of `v`'s elements are `TRUE`.\n\nIn Rcpp, the return type of both all() and any() is not a simple bool, but a more complex type called `SingleLogicalResult`.\n\nThis type can represent not only `TRUE` or `FALSE`, but also `NA` (the third possible logical value in R). As a result, the return value of `all()` or `any()` cannot be directly used in a conditional statement like an `if` statement in C++.\n\nTo convert the `SingleLogicalResult` from `all()` or `any()` into a bool, Rcpp provides helper functions: + is_true(): Returns true if the result is TRUE. + is_false(): Returns true if the result is FALSE. + is_na(): Returns true if the result is NA.\n\n#### `ifelse()`\n\n`ifelse (v, x1, x2)` receives the logical vector `v`, and returns the corresponding element of `x1` when the element of `v` is `TRUE` and the corresponding element of `x2` when it is `FALSE`.\n\n> `x1` and `x2` must either be `scalars` or `vectors`. If they are vectors, their length must match the **length of v**. This ensures that there is a corresponding element in `x1` or `x2` for each element in `v`.\n\n```{r}\nNumericVector v1;\nNumericVector v2;\n//Number of elements of vector\nint n = v1.length();\n```\n\nIn case, both x1 and x2 are scalar\n\n```{r}\nIntegerVector res1     = ifelse( v1>v2, 1, 0);\nNumericVector res2     = ifelse( v1>v2, 1.0, 0.0);\n```\n\n::: callout-important\nSince `ifelse()` does not work with a scalar `character string`, we need to use a string vector whose values of elements are all the same.\n:::\n\n```{r}\nCharacterVector chr_v1 = rep(CharacterVector(\"T\"), n);\nCharacterVector chr_v2 = rep(CharacterVector(\"F\"), n);\nCharacterVector res3   = ifelse( v1>v2, chr_v1, chr_v2);\n```\n\nIn case, `x1` and `x2` are `vector` and `scalar`\n\n```{r}\nIntegerVector res4 = ifelse(v1 > v2, int_v1, 0);\nNumericVector res5 = ifelse(v1 > v2, num_v1, 0.0);\nCharacterVector res6 = ifelse(v1 > v2, chr_v1, Rf_mkChar(\"F\")); // Note\n```\n\n> -   For `integer` and `numeric` vectors, the `scalar` values (0 and 0.0) are recycled as needed\n> -   For `character` vectors, you cannot directly use a scalar string like `\"F\"`; instead, you use `Rf_mkChar(\"F\")`, which creates an internal SEXP (R object) representing the string \"F\".\n\n## Data frame\n\n### Creating DataFrame\n\nIn Rcpp, `DataFrame` is implemented as a kind of vector. In other words, `Vector` is a vector whose element is **scalar** value, while `DataFrame` is a vector whose elements are Vectors of the same length.\n\n`DataFrame::create()` is used to create a DataFrame object.\n\n```{r}\n// Creating DataFrame df from Vector v1, v2\nDataFrame df = DataFrame::create(v1, v2);\n```\n\nAlso, use `Named()` or `_[]` if you want to specify column names when creating DataFrame　object.\n\n```{r}\n// When giving names to columns\nDataFrame df = DataFrame::create( Named(\"V1\") = v1 , _[\"V2\"] = v2 );\n```\n\n::: callout-warning\nWhen you create a DataFrame with `DataFrame::create()`, the value of the originalVector element will **not be duplicated** in the columns of the DataFrame, but the columns will be the **“reference”** to the original Vector. Therefore, changing the value of the original Vector changes the value of the columns. To avoid this, use `clone()`.\n:::\n\n```{r}\ndf <- '#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::export]]\nDataFrame rcpp_df(){\n  // Creating vector v\n  NumericVector v = {1,2};\n  // Creating DataFrame df\n  DataFrame df = DataFrame::create( Named(\"V1\") = v,         // simple assign\n                                    Named(\"V2\") = clone(v)); // using clone()\n  // Changing vector v\n  v = v * 2;\n  return df;\n}'\nsourceCpp(code=df)\nrcpp_df()\n```\n\n### Accessing DataFrame elements\n\nWhen you access a specific column of a DataFrame in Rcpp, that column is temporarily assigned to a `Vector` object. The Vector object allows you to manipulate or access the values of that column as if it were a separate vector.\n\n::: callout-warning\nAs with DataFrame creation, assigning aDataFrame column to Vector in the above way will not copy the column value to Vector object, but it will be a “reference” to the column. Therefore, when you change the values of Vector object, the content of the column will also be changed.\n:::\n\n#### Accessing by Numeric, String, or Logical Vectors\n\nYou can specify which column of the `DataFrame` you want to access using different types of vectors:\n\n-   `Numeric Vector` (Column Number):You can specify a column by its index (0-based). Example: df\\[0\\] would return the first column.\n\n-   `String Vector` (Column Name):You can access a column by its name using a string, which is more intuitive and readable when dealing with named columns.\n\n-   Logical Vector: Each element of the logical vector corresponds to whether a column should be included (`TRUE`) or excluded (`FALSE`). The length of the logical vector must **match the number of columns** in the data frame.\n\n### Member functions\n\n| Method | Description |\n|----|----|\n| `nrows()` | Returns the number of rows. |\n| `ncol()` | Returns the number of columns. |\n| `length()` | Returns the number of columns. |\n| `size()` | Returns the number of columns. |\n| `names()` | Returns the column names as a `CharacterVector`. |\n| `offset(name)` or `findName(name)` | Returns the numerical index of the column with the name specified by the string `name`. |\n| `fill(v)` | Fills all the columns of this `DataFrame` with the `Vector` `v`. |\n| `assign(first_it, last_it)` | Assigns columns in the range specified by the iterators `first_it` and `last_it` to this `DataFrame`. |\n| `push_back(v)` | Adds `Vector v` to the end of the `DataFrame`. |\n| `push_back(v, name)` | Appends a `Vector v` to the end of the `DataFrame` and specifies the name of the added column with the string `name`. |\n| `push_front(x)` | Appends a `Vector v` at the beginning of this `DataFrame`. |\n| `push_front(x, name)` | Appends a `Vector v` at the beginning of this `DataFrame` and specifies the name of the added column with the string `name`. |\n| `begin()` | Returns an iterator pointing to the first column of this `DataFrame`. |\n| `end()` | Returns an iterator pointing to the end of this `DataFrame`. |\n| `insert(it, v)` | Adds `Vector v` to this `DataFrame` at the position pointed by the iterator `it` and returns an iterator to that element. |\n| `erase(i)` | Deletes the `i`-th column of this `DataFrame` and returns an iterator to the column just after the erased column. |\n| `erase(it)` | Deletes the column specified by the iterator `it` and returns an iterator to the column just after the erased column. |\n| `erase(first_i, last_i)` | Deletes columns from `first_i` to `last_i - 1` and returns an iterator to the column just after the erased columns. |\n| `erase(first_it, last_it)` | Deletes the range of columns specified by the iterators `first_it` to `last_it - 1` and returns an iterator to the column just after the erased columns. |\n| `containsElementNamed(name)` | Returns `true` if this `DataFrame` has a column with the name specified by the string `name`. |\n| `inherits(str)` | Returns `true` if the attribute \"class\" of this object contains the string `str`. |\n\n## List\n\nIn Rcpp, `List` is implemented as a kind of `vector`. In other words, Vector is a vector whose element is scalar value, while **List is a vector whose elements are any kinds of data types**.\n\n### Creating List object\n\nTo create a List object we use the `List::create()` function. Also, to specify the element name when creating List, use `Named()` function or `_[]`.\n\n```{r}\n// Create list L from vector v1, v2\nList L = List::create(v1, v2);\n\n// When giving names to elements\nList L = List::create(Named(\"name1\") = v1 , _[\"name2\"] = v2);\n```\n\n::: callout-warning\nWhen you create a `List` with `DataFrame::create()`, the value of the originalVector element will **not be duplicated** but the elements will be the **“reference”** to the original Vector. Therefore, changing the value of the original Vector changes the value of the list. To avoid this, use `clone()`.\n:::\n\n### Accessing List elements\n\nWhen accessing a specific element of List, we **assign** it to the other object and **access it via that object**.\n\nThe elements of List can be specified by numerical index, element names and logical vector.\n\n### Member functions\n\n`List` has the same member functions as `Vector`\n\n## ``` S3``S4 ``` class\n\nThe `S3` class is actually a list whose attribute class has its own value.\n\nWe use an example to demonstrate how to use it in Rcpp\n\n```{r}\ndouble rcpp_rmse(List lm_model) {\n    // Since S3 is a list, data type of the argument is specified as List.\n```\n\n> **S3 objects** in R, such as objects created by `lm()`, are typically lists with an additional `class attribute`. Since an S3 object is fundamentally a list, in Rcpp, we can use the List data type to receive it.\n\n```{r}\nif (! lm_model.inherits(\"lm\")) stop(\"Input must be a lm() model object.\");\n```\n\n> The `inherits(\"lm\")` function checks whether the input object (the list) belongs to the `lm` class. This ensures that the input object is an lm object.\n\n```{r}\n    // Extracting residuals (i.e. actual - prediction) from the S3 object\n    NumericVector resid  = lm_model[\"residuals\"];\n```\n\n> -   In an `lm` object, residuals are stored in the \"residuals\" component.\n> -   Since the S3 object is a `list`, we can access the \"residuals\" component using list-like indexing (lm_model\\[\"residuals\"\\]), which extracts the residuals as a NumericVector in Rcpp.\n\n```{r}\n    // Number of elements of the residual vector\n    R_xlen_t n = resid.length();\n```\n\n> -   The `length()` function is used to get the number of elements in the resid vector (i.e., the number of residuals).\n> -   `R_xlen_t` is a type that represents the length of vectors in R. It is typically used in Rcpp when dealing with vector lengths.\n\n::: callout-tips\n`R_xlen_t` is large enough to handle **very long vectors**, which is crucial when you’re working with vectors whose length might **exceed the range of a standard integer** (which is 2\\^31 - 1 in R, roughly 2 billion).\n:::\n\n```{r}\n    // The sum of squares of the residual vector\n    double rmse(0.0);\n    for(double& r : resid){\n        rmse += r*r;\n    }\n\n    // Divide the residual sum of squares by the number of elements and take the square root\n    return(sqrt((1.0/n)*rmse));\n}\n```\n\n### `S4` class\n\nwait to update.\n\n## String\n\n`String` is a scalar type corresponding to the element of `CharacterVector`. String can also handle `NA` values (`NA_STRING`) which are not supported by the C character string `char*` and the C++ string `std::string`.\n\n### Creating String object\n\nThere are three main ways to create a String object. Each approach reflects different sources for creating the String object:\n\n1.  Creating a String from a `C/C++ String` (`Character Pointer` or `std::string`):\n\n```{r}\n// Create String from C-style string\nString s1 = \"Hello, world!\";\n\n// Create String from std::string\nstd::string cpp_str = \"C++ string\";\nString s2 = cpp_str;\n```\n\n> -   s1 is created from a **C-style** string (`\"Hello, world!\"`).\n> -   s2 is created from a **C++** string (`std::string`).\n\n2.  Creating a String from Another String Object:\n\n-   You can create a new String object by copying an existing String object in Rcpp.\n\n```{r}\nString s1 = \"Original string\";\n\n// Create a new String from another String object\nString s2 = s1;\n```\n\n3.  Creating a String from an Element of a `CharacterVector`:\n\n```{r}\nCharacterVector cv = CharacterVector::create(\"one\", \"two\", \"three\");\n\n// Create a String from the second element of the CharacterVector\nString s = cv[1];  // Note: 0-based indexing, so this accesses \"two\"\n```\n\n### Operators\n\nIn Rcpp, the String class supports the `+=` operator, which allows you to **append** another string (or string-like object) to an existing String object.\n\n```{r}\n// Creating String object\nString s(\"A\");\n\n// Conbining a string\ns += \"B\";\n\nRcout << s << \"\\n\"; \n// \"AB\"\n```\n\n### Member functions\n\n| Method | Description |\n|----|----|\n| `replace_first(str, new_str)` | Replace the first substring that matches the string `str` with the string `new_str`. |\n| `replace_last(str, new_str)` | Replace the last substring that matches the string `str` with the string `new_str`. |\n| `replace_all(str, new_str)` | Replace all substrings that match the string `str` with the string `new_str`. |\n| `push_back(str)` | Combine the string `str` to the end of this `String` object. (Same as `+=` operator) |\n| `push_front(str)` | Combine the string `str` at the beginning of this `String` object. |\n| `set_na()` | Set NA value to this `String` object. |\n| `get_cstring()` | Convert the string of this `String` object into a C character string constant (`const char*`) and return it. |\n| `get_encoding()` | Returns the character encoding. The encoding is represented by `cettype_t`. |\n| `set_encoding(enc)` | Set the character encoding specified by `cettype_t`. |\n\n## Date and DateVector\n\n### Creating Date objects\n\nThe following codes illustrates different ways to create a Date object in Rcpp, representing a specific date.\n\n```{r}\nDate d;  // \"1970-01-01\"\n```\n\n> -   `Date d`; creates a Date object d that represents the epoch date \"1970-01-01\", which is considered the default starting point for dates in many computing systems, including R.\n\n```{r}\nDate d(1);  // \"1970-01-01\" + 1 day\n```\n\n> -   `Date d(1)`; creates a Date object d that represents one day after the epoch date.\n\n```{r}\nDate d(1.1);  // \"1970-01-01\" + ceil(1.1) day\n```\n\n> -   `Date d(1.1)`; creates a Date object `d` that represents 1.1 days after “1970-01-01”. The number is rounded up (`using ceil()`), so it is treated as 2 days after “1970-01-01”.\n\n```{r}\nDate d(\"2000-01-01\", \"%Y-%m-%d\");  // Date specified by a string with a format\n```\n\n> This creates a Date object `d` from a string `\"2000-01-01\"` with the format `\"%Y-%m-%d\"`\n\nDate from `Day`, `Month`, and `Year` `(mm/dd/yyyy)`:\n\n```{r}\nDate d(1, 2, 2000);  // 2000-01-02 (mon, day, year)\n```\n\n### Operators\n\n`Date` has operators `+`, `-`, `<`, `>`, `>=`, `<=`, `==`, `!=`.\n\nBy using these operators, you can perform addition of days (`+`), difference calculation of date (`-`), and comparison of dates (`<`, `<=`, `>`, `>=`, `==`, `!=`) . \\### Member functions\n\n| Method | Description |\n|----|----|\n| `format()` | Returns the date as a `std::string` using the same specification as base R. The default format is `YYYY-MM-DD`. |\n| `getDay()` | Returns the day of the date. |\n| `getMonth()` | Returns the month of the date. |\n| `getYear()` | Returns the year of the date. |\n| `getWeekday()` | Returns the day of the week as an int. (`1:Sun`, `2:Mon`, `3:Tue`, `4:Wed`, `5:Thu`, `6:Sat`). |\n| `getYearday()` | Returns the number of the date through the year (with January 1st as 1 and December 31st as 365). |\n| `is_na()` | Returns `true` if this object is NA. |\n\n### DateVector subsetting\n\nIn Rcpp, both `DateVector` and `DateTimeVector` are internally stored as numeric types (specifically, doubles). This design simplifies certain internal calculations but can be confusing when working with individual elements of these vectors.\n\nThis behavior is important because when you subset a DateVector using the `[]` operator, you extract a `double`, which represents the date as the number of days since the `epoch date` (1970-01-01).\n\nTo work with individual `Date` or `DateTime` objects from a `DateVector` or `DateTimeVector`, you need to explicitly cast or convert the extracted element back into a `Date` or `DateTime` object.\n\nExample:\n\n```{r}\n// [[Rcpp::export]]\nvoid print_year_of_date(DateVector dates) {\n    for (int i = 0; i < dates.size(); ++i) {\n        // Convert the extracted double to a Date object\n        Date single_date = dates[i];  // Convert double to Date\n        int year = single_date.getYear();  // Now you can call getYear()\n        Rcpp::Rcout << \"Year: \" << year << std::endl;\n    }\n}\n```\n\n> -   dates\\[i\\] returns a double by default.\n> -   Date single_date = dates\\[i\\];: We explicitly convert the double value to a Date object, allowing us to use the getYear() method.\n\n## RObject\n\nThe `RObject` type in Rcpp is a flexible and general-purpose type that can **represent any kind of R object**.\n\nHere is an example that demonstrates how RObject can be used in Rcpp to accept and handle different types of R objects.\n\n```{r}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nvoid handle_any_type(RObject obj) {\n    // Check if the object is a NumericVector\n    if (obj.is<NumericVector>()) {\n        NumericVector num_vec = as<NumericVector>(obj);\n        Rcpp::Rcout << \"Numeric Vector: \" << num_vec << std::endl;\n    } \n    // Check if the object is a CharacterVector\n    else if (obj.is<CharacterVector>()) {\n        CharacterVector char_vec = as<CharacterVector>(obj);\n        Rcpp::Rcout << \"Character Vector: \" << char_vec << std::endl;\n    } \n    // Check if the object is a List\n    else if (obj.is<List>()) {\n        List lst = as<List>(obj);\n        Rcpp::Rcout << \"List: \" << lst << std::endl;\n    } \n    // Handle unknown types\n    else {\n        Rcpp::Rcout << \"Unknown type!\" << std::endl;\n    }\n}\n```\n\n### Cnversion using `as<>()`:\n\n-   `as<>()` is a template function in Rcpp that allows you to convert an `RObject` to a more specific type when you know the type of the object or have determined it dynamically.\n\n```{r}\nNumericVector num_vec = as<NumericVector>(obj);  // Convert RObject to NumericVector\n```\n\n> This converts the RObject into a NumericVector when you are sure that it contains a numeric vector.\n\n## Cautions in handling Rcpp objects\n\n### Assigning between vectors\n\nIn Rcpp, when you assign an object (like a vector, list, or matrix) v1 to another object v2 using the `=` operator (e.g., `v2 = v1`;), **no deep copy** is made. Instead, v2 **becomes an alias** to v1, meaning that both v1 and v2 point to **the same underlying data in memory**.\n\nIf you want v2 to be a completely independent copy of `v1`, so that changes to `v1` do not affect `v2`, you need to perform a **deep copy**. In Rcpp, you can use the `clone()` function to create a deep copy.\n\n### Data type of numerical index\n\nYou should use `R_xlen_t` as data type for numerical index or the number of elements to support **long vector** in your Rcpp code.\n\n### Return type of operator `[]`\n\nIn Rcpp, when you access an element of a vector with \\[\\] or (), you do not directly get the element as its native type (e.g., double, int, or String). Instead, you get a Vector::Proxy object. This Proxy object acts as an intermediary that allows you to modify the vector element directly or retrieve its value, but **it is not the same as the element’s actual type**.\n\nTo resolve this, you either: + **Assign** `v[i]` to a new object of the expected type. + **Convert** the Proxy to the native type using `as<T>()`.\n\n## R-like functions\n\nHere is a list of Rcpp functions similar to R functions.\n\nIf you know for certain that your vector **does not contain any NA values**, you can optimize your code by using the `noNA()` function. `noNA()` marks the vector as guaranteed to be free of `NA` values, which allows Rcpp to skip `NA` checks and perform calculations more efficiently.\n\n> List is too long to illustrate.\n\n## Probability distribution\n\nIn Rcpp, probability distribution functions exist in two different namespaces:\n\n1.  `Rcpp::` namespace:\n\n-   Functions in this namespace return vectors.\n\n-   These functions are designed to be similar to their counterparts in base R. You can pass a vector of values to these functions and they will return a vector of results.\n\n2.  `R::` namespace:\n\n-   Functions in this namespace return scalar values (a single value).\n-   If you only need a single value from the distribution function, using the R:: version of the function can be more efficient because it avoids the overhead of vectorization.\n\n```{r}\nsort_cpp <- '#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::export]]\nNumericVector sort_numeric_vector(NumericVector x) {\n    std::sort(x.begin(), x.end());\n    return x;\n}'\nsourceCpp(code=sort_cpp)\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../style.css"],"highlight-style":"breeze","toc":true,"toc-depth":2,"number-sections":true,"output-file":"Rcpp study.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":"cosmo","title-block-banner":true,"title":"Rcpp Study Record","author":"Creo Hsia","date":"2024-10-10","description":"Record my study in Rcpp","knitr":{"opts_chunk":{"collapse":true,"comment":"#>"}},"code-copy":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}